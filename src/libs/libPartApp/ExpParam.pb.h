// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ExpParam.proto

#ifndef PROTOBUF_ExpParam_2eproto__INCLUDED
#define PROTOBUF_ExpParam_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ExpParam_2eproto();
void protobuf_AssignDesc_ExpParam_2eproto();
void protobuf_ShutdownFile_ExpParam_2eproto();

class ExpParam;

// ===================================================================

class ExpParam : public ::google::protobuf::Message {
 public:
  ExpParam();
  virtual ~ExpParam();
  
  ExpParam(const ExpParam& from);
  
  inline ExpParam& operator=(const ExpParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExpParam& default_instance();
  
  void Swap(ExpParam* other);
  
  // implements Message ----------------------------------------------
  
  ExpParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExpParam& from);
  void MergeFrom(const ExpParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string train_dataset = 1;
  inline int train_dataset_size() const;
  inline void clear_train_dataset();
  static const int kTrainDatasetFieldNumber = 1;
  inline const ::std::string& train_dataset(int index) const;
  inline ::std::string* mutable_train_dataset(int index);
  inline void set_train_dataset(int index, const ::std::string& value);
  inline void set_train_dataset(int index, const char* value);
  inline void set_train_dataset(int index, const char* value, size_t size);
  inline ::std::string* add_train_dataset();
  inline void add_train_dataset(const ::std::string& value);
  inline void add_train_dataset(const char* value);
  inline void add_train_dataset(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& train_dataset() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_train_dataset();
  
  // repeated string validation_dataset = 8;
  inline int validation_dataset_size() const;
  inline void clear_validation_dataset();
  static const int kValidationDatasetFieldNumber = 8;
  inline const ::std::string& validation_dataset(int index) const;
  inline ::std::string* mutable_validation_dataset(int index);
  inline void set_validation_dataset(int index, const ::std::string& value);
  inline void set_validation_dataset(int index, const char* value);
  inline void set_validation_dataset(int index, const char* value, size_t size);
  inline ::std::string* add_validation_dataset();
  inline void add_validation_dataset(const ::std::string& value);
  inline void add_validation_dataset(const char* value);
  inline void add_validation_dataset(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& validation_dataset() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_validation_dataset();
  
  // repeated string test_dataset = 2;
  inline int test_dataset_size() const;
  inline void clear_test_dataset();
  static const int kTestDatasetFieldNumber = 2;
  inline const ::std::string& test_dataset(int index) const;
  inline ::std::string* mutable_test_dataset(int index);
  inline void set_test_dataset(int index, const ::std::string& value);
  inline void set_test_dataset(int index, const char* value);
  inline void set_test_dataset(int index, const char* value, size_t size);
  inline ::std::string* add_test_dataset();
  inline void add_test_dataset(const ::std::string& value);
  inline void add_test_dataset(const char* value);
  inline void add_test_dataset(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& test_dataset() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_test_dataset();
  
  // repeated string neg_dataset = 51;
  inline int neg_dataset_size() const;
  inline void clear_neg_dataset();
  static const int kNegDatasetFieldNumber = 51;
  inline const ::std::string& neg_dataset(int index) const;
  inline ::std::string* mutable_neg_dataset(int index);
  inline void set_neg_dataset(int index, const ::std::string& value);
  inline void set_neg_dataset(int index, const char* value);
  inline void set_neg_dataset(int index, const char* value, size_t size);
  inline ::std::string* add_neg_dataset();
  inline void add_neg_dataset(const ::std::string& value);
  inline void add_neg_dataset(const char* value);
  inline void add_neg_dataset(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& neg_dataset() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_neg_dataset();
  
  // repeated string bootstrap_dataset = 86;
  inline int bootstrap_dataset_size() const;
  inline void clear_bootstrap_dataset();
  static const int kBootstrapDatasetFieldNumber = 86;
  inline const ::std::string& bootstrap_dataset(int index) const;
  inline ::std::string* mutable_bootstrap_dataset(int index);
  inline void set_bootstrap_dataset(int index, const ::std::string& value);
  inline void set_bootstrap_dataset(int index, const char* value);
  inline void set_bootstrap_dataset(int index, const char* value, size_t size);
  inline ::std::string* add_bootstrap_dataset();
  inline void add_bootstrap_dataset(const ::std::string& value);
  inline void add_bootstrap_dataset(const char* value);
  inline void add_bootstrap_dataset(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bootstrap_dataset() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bootstrap_dataset();
  
  // repeated string train_dataset_reshaped = 39;
  inline int train_dataset_reshaped_size() const;
  inline void clear_train_dataset_reshaped();
  static const int kTrainDatasetReshapedFieldNumber = 39;
  inline const ::std::string& train_dataset_reshaped(int index) const;
  inline ::std::string* mutable_train_dataset_reshaped(int index);
  inline void set_train_dataset_reshaped(int index, const ::std::string& value);
  inline void set_train_dataset_reshaped(int index, const char* value);
  inline void set_train_dataset_reshaped(int index, const char* value, size_t size);
  inline ::std::string* add_train_dataset_reshaped();
  inline void add_train_dataset_reshaped(const ::std::string& value);
  inline void add_train_dataset_reshaped(const char* value);
  inline void add_train_dataset_reshaped(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& train_dataset_reshaped() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_train_dataset_reshaped();
  
  // optional string log_dir = 3;
  inline bool has_log_dir() const;
  inline void clear_log_dir();
  static const int kLogDirFieldNumber = 3;
  inline const ::std::string& log_dir() const;
  inline void set_log_dir(const ::std::string& value);
  inline void set_log_dir(const char* value);
  inline void set_log_dir(const char* value, size_t size);
  inline ::std::string* mutable_log_dir();
  
  // optional string log_subdir = 7;
  inline bool has_log_subdir() const;
  inline void clear_log_subdir();
  static const int kLogSubdirFieldNumber = 7;
  inline const ::std::string& log_subdir() const;
  inline void set_log_subdir(const ::std::string& value);
  inline void set_log_subdir(const char* value);
  inline void set_log_subdir(const char* value, size_t size);
  inline ::std::string* mutable_log_subdir();
  
  // optional string class_dir = 4;
  inline bool has_class_dir() const;
  inline void clear_class_dir();
  static const int kClassDirFieldNumber = 4;
  inline const ::std::string& class_dir() const;
  inline void set_class_dir(const ::std::string& value);
  inline void set_class_dir(const char* value);
  inline void set_class_dir(const char* value, size_t size);
  inline ::std::string* mutable_class_dir();
  
  // repeated string comp_class_dir = 50;
  inline int comp_class_dir_size() const;
  inline void clear_comp_class_dir();
  static const int kCompClassDirFieldNumber = 50;
  inline const ::std::string& comp_class_dir(int index) const;
  inline ::std::string* mutable_comp_class_dir(int index);
  inline void set_comp_class_dir(int index, const ::std::string& value);
  inline void set_comp_class_dir(int index, const char* value);
  inline void set_comp_class_dir(int index, const char* value, size_t size);
  inline ::std::string* add_comp_class_dir();
  inline void add_comp_class_dir(const ::std::string& value);
  inline void add_comp_class_dir(const char* value);
  inline void add_comp_class_dir(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& comp_class_dir() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_comp_class_dir();
  
  // optional string scoregrid_dir = 16;
  inline bool has_scoregrid_dir() const;
  inline void clear_scoregrid_dir();
  static const int kScoregridDirFieldNumber = 16;
  inline const ::std::string& scoregrid_dir() const;
  inline void set_scoregrid_dir(const ::std::string& value);
  inline void set_scoregrid_dir(const char* value);
  inline void set_scoregrid_dir(const char* value, size_t size);
  inline ::std::string* mutable_scoregrid_dir();
  
  // optional string scoregrid_train_dir = 44;
  inline bool has_scoregrid_train_dir() const;
  inline void clear_scoregrid_train_dir();
  static const int kScoregridTrainDirFieldNumber = 44;
  inline const ::std::string& scoregrid_train_dir() const;
  inline void set_scoregrid_train_dir(const ::std::string& value);
  inline void set_scoregrid_train_dir(const char* value);
  inline void set_scoregrid_train_dir(const char* value, size_t size);
  inline ::std::string* mutable_scoregrid_train_dir();
  
  // optional bool normalize_kmeans = 81 [default = false];
  inline bool has_normalize_kmeans() const;
  inline void clear_normalize_kmeans();
  static const int kNormalizeKmeansFieldNumber = 81;
  inline bool normalize_kmeans() const;
  inline void set_normalize_kmeans(bool value);
  
  // optional uint32 ndim_joint = 82 [default = 2];
  inline bool has_ndim_joint() const;
  inline void clear_ndim_joint();
  static const int kNdimJointFieldNumber = 82;
  inline ::google::protobuf::uint32 ndim_joint() const;
  inline void set_ndim_joint(::google::protobuf::uint32 value);
  
  // optional uint32 poselet_strip = 83 [default = 40];
  inline bool has_poselet_strip() const;
  inline void clear_poselet_strip();
  static const int kPoseletStripFieldNumber = 83;
  inline ::google::protobuf::uint32 poselet_strip() const;
  inline void set_poselet_strip(::google::protobuf::uint32 value);
  
  // optional float vis_weight = 84 [default = 0];
  inline bool has_vis_weight() const;
  inline void clear_vis_weight();
  static const int kVisWeightFieldNumber = 84;
  inline float vis_weight() const;
  inline void set_vis_weight(float value);
  
  // optional float vp_weight = 85 [default = 0];
  inline bool has_vp_weight() const;
  inline void clear_vp_weight();
  static const int kVpWeightFieldNumber = 85;
  inline float vp_weight() const;
  inline void set_vp_weight(float value);
  
  // optional float bootstrap_threshold = 88 [default = 0.3];
  inline bool has_bootstrap_threshold() const;
  inline void clear_bootstrap_threshold();
  static const int kBootstrapThresholdFieldNumber = 88;
  inline float bootstrap_threshold() const;
  inline void set_bootstrap_threshold(float value);
  
  // optional int32 num_best_part_det_vis = 90 [default = 1];
  inline bool has_num_best_part_det_vis() const;
  inline void clear_num_best_part_det_vis();
  static const int kNumBestPartDetVisFieldNumber = 90;
  inline ::google::protobuf::int32 num_best_part_det_vis() const;
  inline void set_num_best_part_det_vis(::google::protobuf::int32 value);
  
  // optional float min_clus_size = 92 [default = 10];
  inline bool has_min_clus_size() const;
  inline void clear_min_clus_size();
  static const int kMinClusSizeFieldNumber = 92;
  inline float min_clus_size() const;
  inline void set_min_clus_size(float value);
  
  // optional bool pred_unary_rot = 93 [default = false];
  inline bool has_pred_unary_rot() const;
  inline void clear_pred_unary_rot();
  static const int kPredUnaryRotFieldNumber = 93;
  inline bool pred_unary_rot() const;
  inline void set_pred_unary_rot(bool value);
  
  // optional float pred_unary_pos_weight = 95 [default = 1];
  inline bool has_pred_unary_pos_weight() const;
  inline void clear_pred_unary_pos_weight();
  static const int kPredUnaryPosWeightFieldNumber = 95;
  inline float pred_unary_pos_weight() const;
  inline void set_pred_unary_pos_weight(float value);
  
  // optional float pred_unary_rot_weight = 96 [default = 1];
  inline bool has_pred_unary_rot_weight() const;
  inline void clear_pred_unary_rot_weight();
  static const int kPredUnaryRotWeightFieldNumber = 96;
  inline float pred_unary_rot_weight() const;
  inline void set_pred_unary_rot_weight(float value);
  
  // optional uint32 pred_unary_rot_comp = 97 [default = 1];
  inline bool has_pred_unary_rot_comp() const;
  inline void clear_pred_unary_rot_comp();
  static const int kPredUnaryRotCompFieldNumber = 97;
  inline ::google::protobuf::uint32 pred_unary_rot_comp() const;
  inline void set_pred_unary_rot_comp(::google::protobuf::uint32 value);
  
  // optional string pred_data_dir = 98;
  inline bool has_pred_data_dir() const;
  inline void clear_pred_data_dir();
  static const int kPredDataDirFieldNumber = 98;
  inline const ::std::string& pred_data_dir() const;
  inline void set_pred_data_dir(const ::std::string& value);
  inline void set_pred_data_dir(const char* value);
  inline void set_pred_data_dir(const char* value, size_t size);
  inline ::std::string* mutable_pred_data_dir();
  
  // optional string pred_data_test_dir = 135;
  inline bool has_pred_data_test_dir() const;
  inline void clear_pred_data_test_dir();
  static const int kPredDataTestDirFieldNumber = 135;
  inline const ::std::string& pred_data_test_dir() const;
  inline void set_pred_data_test_dir(const ::std::string& value);
  inline void set_pred_data_test_dir(const char* value);
  inline void set_pred_data_test_dir(const char* value, size_t size);
  inline ::std::string* mutable_pred_data_test_dir();
  
  // optional string poselet_resp_val_dir = 137;
  inline bool has_poselet_resp_val_dir() const;
  inline void clear_poselet_resp_val_dir();
  static const int kPoseletRespValDirFieldNumber = 137;
  inline const ::std::string& poselet_resp_val_dir() const;
  inline void set_poselet_resp_val_dir(const ::std::string& value);
  inline void set_poselet_resp_val_dir(const char* value);
  inline void set_poselet_resp_val_dir(const char* value, size_t size);
  inline ::std::string* mutable_poselet_resp_val_dir();
  
  // optional string poselet_resp_test_dir = 138;
  inline bool has_poselet_resp_test_dir() const;
  inline void clear_poselet_resp_test_dir();
  static const int kPoseletRespTestDirFieldNumber = 138;
  inline const ::std::string& poselet_resp_test_dir() const;
  inline void set_poselet_resp_test_dir(const ::std::string& value);
  inline void set_poselet_resp_test_dir(const char* value);
  inline void set_poselet_resp_test_dir(const char* value, size_t size);
  inline ::std::string* mutable_poselet_resp_test_dir();
  
  // optional string spatial_dir = 139;
  inline bool has_spatial_dir() const;
  inline void clear_spatial_dir();
  static const int kSpatialDirFieldNumber = 139;
  inline const ::std::string& spatial_dir() const;
  inline void set_spatial_dir(const ::std::string& value);
  inline void set_spatial_dir(const char* value);
  inline void set_spatial_dir(const char* value, size_t size);
  inline ::std::string* mutable_spatial_dir();
  
  // optional float dpm_torso_weight = 99 [default = 1];
  inline bool has_dpm_torso_weight() const;
  inline void clear_dpm_torso_weight();
  static const int kDpmTorsoWeightFieldNumber = 99;
  inline float dpm_torso_weight() const;
  inline void set_dpm_torso_weight(float value);
  
  // optional bool force_recompute_scores = 101 [default = true];
  inline bool has_force_recompute_scores() const;
  inline void clear_force_recompute_scores();
  static const int kForceRecomputeScoresFieldNumber = 101;
  inline bool force_recompute_scores() const;
  inline void set_force_recompute_scores(bool value);
  
  // optional float torso_pos_prior_weight = 105 [default = 1];
  inline bool has_torso_pos_prior_weight() const;
  inline void clear_torso_pos_prior_weight();
  static const int kTorsoPosPriorWeightFieldNumber = 105;
  inline float torso_pos_prior_weight() const;
  inline void set_torso_pos_prior_weight(float value);
  
  // optional string torso_det_test_dir = 107;
  inline bool has_torso_det_test_dir() const;
  inline void clear_torso_det_test_dir();
  static const int kTorsoDetTestDirFieldNumber = 107;
  inline const ::std::string& torso_det_test_dir() const;
  inline void set_torso_det_test_dir(const ::std::string& value);
  inline void set_torso_det_test_dir(const char* value);
  inline void set_torso_det_test_dir(const char* value, size_t size);
  inline ::std::string* mutable_torso_det_test_dir();
  
  // optional string torso_det_train_dir = 108;
  inline bool has_torso_det_train_dir() const;
  inline void clear_torso_det_train_dir();
  static const int kTorsoDetTrainDirFieldNumber = 108;
  inline const ::std::string& torso_det_train_dir() const;
  inline void set_torso_det_train_dir(const ::std::string& value);
  inline void set_torso_det_train_dir(const char* value);
  inline void set_torso_det_train_dir(const char* value, size_t size);
  inline ::std::string* mutable_torso_det_train_dir();
  
  // optional uint32 poselet_rot_strip = 109;
  inline bool has_poselet_rot_strip() const;
  inline void clear_poselet_rot_strip();
  static const int kPoseletRotStripFieldNumber = 109;
  inline ::google::protobuf::uint32 poselet_rot_strip() const;
  inline void set_poselet_rot_strip(::google::protobuf::uint32 value);
  
  // optional uint32 rootidx_det = 110 [default = 1000];
  inline bool has_rootidx_det() const;
  inline void clear_rootidx_det();
  static const int kRootidxDetFieldNumber = 110;
  inline ::google::protobuf::uint32 rootidx_det() const;
  inline void set_rootidx_det(::google::protobuf::uint32 value);
  
  // optional bool use_gt_torso = 111 [default = false];
  inline bool has_use_gt_torso() const;
  inline void clear_use_gt_torso();
  static const int kUseGtTorsoFieldNumber = 111;
  inline bool use_gt_torso() const;
  inline void set_use_gt_torso(bool value);
  
  // optional bool use_dpm_torso = 112 [default = false];
  inline bool has_use_dpm_torso() const;
  inline void clear_use_dpm_torso();
  static const int kUseDpmTorsoFieldNumber = 112;
  inline bool use_dpm_torso() const;
  inline void set_use_dpm_torso(bool value);
  
  // optional bool pred_unary_pos = 114 [default = false];
  inline bool has_pred_unary_pos() const;
  inline void clear_pred_unary_pos();
  static const int kPredUnaryPosFieldNumber = 114;
  inline bool pred_unary_pos() const;
  inline void set_pred_unary_pos(bool value);
  
  // optional bool use_torso_pos_prior = 120 [default = false];
  inline bool has_use_torso_pos_prior() const;
  inline void clear_use_torso_pos_prior();
  static const int kUseTorsoPosPriorFieldNumber = 120;
  inline bool use_torso_pos_prior() const;
  inline void set_use_torso_pos_prior(bool value);
  
  // optional bool use_dpm_head = 122 [default = false];
  inline bool has_use_dpm_head() const;
  inline void clear_use_dpm_head();
  static const int kUseDpmHeadFieldNumber = 122;
  inline bool use_dpm_head() const;
  inline void set_use_dpm_head(bool value);
  
  // optional float dpm_head_weight = 125 [default = 1];
  inline bool has_dpm_head_weight() const;
  inline void clear_dpm_head_weight();
  static const int kDpmHeadWeightFieldNumber = 125;
  inline float dpm_head_weight() const;
  inline void set_dpm_head_weight(float value);
  
  // optional string test_dpm_unary_dir = 126;
  inline bool has_test_dpm_unary_dir() const;
  inline void clear_test_dpm_unary_dir();
  static const int kTestDpmUnaryDirFieldNumber = 126;
  inline const ::std::string& test_dpm_unary_dir() const;
  inline void set_test_dpm_unary_dir(const ::std::string& value);
  inline void set_test_dpm_unary_dir(const char* value);
  inline void set_test_dpm_unary_dir(const char* value, size_t size);
  inline ::std::string* mutable_test_dpm_unary_dir();
  
  // optional float dpm_unary_weight = 127 [default = 1];
  inline bool has_dpm_unary_weight() const;
  inline void clear_dpm_unary_weight();
  static const int kDpmUnaryWeightFieldNumber = 127;
  inline float dpm_unary_weight() const;
  inline void set_dpm_unary_weight(float value);
  
  // optional bool use_dpm_unary = 128 [default = false];
  inline bool has_use_dpm_unary() const;
  inline void clear_use_dpm_unary();
  static const int kUseDpmUnaryFieldNumber = 128;
  inline bool use_dpm_unary() const;
  inline void set_use_dpm_unary(bool value);
  
  // optional bool do_dpm_rot = 131 [default = false];
  inline bool has_do_dpm_rot() const;
  inline void clear_do_dpm_rot();
  static const int kDoDpmRotFieldNumber = 131;
  inline bool do_dpm_rot() const;
  inline void set_do_dpm_rot(bool value);
  
  // optional bool use_pairwise = 132 [default = true];
  inline bool has_use_pairwise() const;
  inline void clear_use_pairwise();
  static const int kUsePairwiseFieldNumber = 132;
  inline bool use_pairwise() const;
  inline void set_use_pairwise(bool value);
  
  // optional bool save_part_marginals = 133 [default = false];
  inline bool has_save_part_marginals() const;
  inline void clear_save_part_marginals();
  static const int kSavePartMarginalsFieldNumber = 133;
  inline bool save_part_marginals() const;
  inline void set_save_part_marginals(bool value);
  
  // optional string dpm_model_dir = 134;
  inline bool has_dpm_model_dir() const;
  inline void clear_dpm_model_dir();
  static const int kDpmModelDirFieldNumber = 134;
  inline const ::std::string& dpm_model_dir() const;
  inline void set_dpm_model_dir(const ::std::string& value);
  inline void set_dpm_model_dir(const char* value);
  inline void set_dpm_model_dir(const char* value, size_t size);
  inline ::std::string* mutable_dpm_model_dir();
  
  // optional float unary_weight = 56 [default = 1];
  inline bool has_unary_weight() const;
  inline void clear_unary_weight();
  static const int kUnaryWeightFieldNumber = 56;
  inline float unary_weight() const;
  inline void set_unary_weight(float value);
  
  // optional bool interpolate = 77 [default = false];
  inline bool has_interpolate() const;
  inline void clear_interpolate();
  static const int kInterpolateFieldNumber = 77;
  inline bool interpolate() const;
  inline void set_interpolate(bool value);
  
  // optional string pos_dpm_torso_dir = 69;
  inline bool has_pos_dpm_torso_dir() const;
  inline void clear_pos_dpm_torso_dir();
  static const int kPosDpmTorsoDirFieldNumber = 69;
  inline const ::std::string& pos_dpm_torso_dir() const;
  inline void set_pos_dpm_torso_dir(const ::std::string& value);
  inline void set_pos_dpm_torso_dir(const char* value);
  inline void set_pos_dpm_torso_dir(const char* value, size_t size);
  inline ::std::string* mutable_pos_dpm_torso_dir();
  
  // optional string test_dpm_torso_dir = 71;
  inline bool has_test_dpm_torso_dir() const;
  inline void clear_test_dpm_torso_dir();
  static const int kTestDpmTorsoDirFieldNumber = 71;
  inline const ::std::string& test_dpm_torso_dir() const;
  inline void set_test_dpm_torso_dir(const ::std::string& value);
  inline void set_test_dpm_torso_dir(const char* value);
  inline void set_test_dpm_torso_dir(const char* value, size_t size);
  inline ::std::string* mutable_test_dpm_torso_dir();
  
  // optional uint32 torso_hyp_idx = 72;
  inline bool has_torso_hyp_idx() const;
  inline void clear_torso_hyp_idx();
  static const int kTorsoHypIdxFieldNumber = 72;
  inline ::google::protobuf::uint32 torso_hyp_idx() const;
  inline void set_torso_hyp_idx(::google::protobuf::uint32 value);
  
  // optional string part_marginals_dir = 73;
  inline bool has_part_marginals_dir() const;
  inline void clear_part_marginals_dir();
  static const int kPartMarginalsDirFieldNumber = 73;
  inline const ::std::string& part_marginals_dir() const;
  inline void set_part_marginals_dir(const ::std::string& value);
  inline void set_part_marginals_dir(const char* value);
  inline void set_part_marginals_dir(const char* value, size_t size);
  inline ::std::string* mutable_part_marginals_dir();
  
  // optional string part_conf = 5;
  inline bool has_part_conf() const;
  inline void clear_part_conf();
  static const int kPartConfFieldNumber = 5;
  inline const ::std::string& part_conf() const;
  inline void set_part_conf(const ::std::string& value);
  inline void set_part_conf(const char* value);
  inline void set_part_conf(const char* value, size_t size);
  inline ::std::string* mutable_part_conf();
  
  // optional string part_conf_eval = 32;
  inline bool has_part_conf_eval() const;
  inline void clear_part_conf_eval();
  static const int kPartConfEvalFieldNumber = 32;
  inline const ::std::string& part_conf_eval() const;
  inline void set_part_conf_eval(const ::std::string& value);
  inline void set_part_conf_eval(const char* value);
  inline void set_part_conf_eval(const char* value, size_t size);
  inline ::std::string* mutable_part_conf_eval();
  
  // optional string part_conf_type = 33 [default = "human_full"];
  inline bool has_part_conf_type() const;
  inline void clear_part_conf_type();
  static const int kPartConfTypeFieldNumber = 33;
  inline const ::std::string& part_conf_type() const;
  inline void set_part_conf_type(const ::std::string& value);
  inline void set_part_conf_type(const char* value);
  inline void set_part_conf_type(const char* value, size_t size);
  inline ::std::string* mutable_part_conf_type();
  
  // optional string abc_param = 6;
  inline bool has_abc_param() const;
  inline void clear_abc_param();
  static const int kAbcParamFieldNumber = 6;
  inline const ::std::string& abc_param() const;
  inline void set_abc_param(const ::std::string& value);
  inline void set_abc_param(const char* value);
  inline void set_abc_param(const char* value, size_t size);
  inline ::std::string* mutable_abc_param();
  
  // optional float min_object_scale = 9 [default = 1];
  inline bool has_min_object_scale() const;
  inline void clear_min_object_scale();
  static const int kMinObjectScaleFieldNumber = 9;
  inline float min_object_scale() const;
  inline void set_min_object_scale(float value);
  
  // optional float max_object_scale = 10 [default = 1];
  inline bool has_max_object_scale() const;
  inline void clear_max_object_scale();
  static const int kMaxObjectScaleFieldNumber = 10;
  inline float max_object_scale() const;
  inline void set_max_object_scale(float value);
  
  // optional uint32 num_scale_steps = 11 [default = 1];
  inline bool has_num_scale_steps() const;
  inline void clear_num_scale_steps();
  static const int kNumScaleStepsFieldNumber = 11;
  inline ::google::protobuf::uint32 num_scale_steps() const;
  inline void set_num_scale_steps(::google::protobuf::uint32 value);
  
  // optional float min_part_rotation = 12 [default = -180];
  inline bool has_min_part_rotation() const;
  inline void clear_min_part_rotation();
  static const int kMinPartRotationFieldNumber = 12;
  inline float min_part_rotation() const;
  inline void set_min_part_rotation(float value);
  
  // optional float max_part_rotation = 13 [default = 180];
  inline bool has_max_part_rotation() const;
  inline void clear_max_part_rotation();
  static const int kMaxPartRotationFieldNumber = 13;
  inline float max_part_rotation() const;
  inline void set_max_part_rotation(float value);
  
  // optional uint32 num_rotation_steps = 14 [default = 48];
  inline bool has_num_rotation_steps() const;
  inline void clear_num_rotation_steps();
  static const int kNumRotationStepsFieldNumber = 14;
  inline ::google::protobuf::uint32 num_rotation_steps() const;
  inline void set_num_rotation_steps(::google::protobuf::uint32 value);
  
  // optional bool flip_orientation = 15 [default = false];
  inline bool has_flip_orientation() const;
  inline void clear_flip_orientation();
  static const int kFlipOrientationFieldNumber = 15;
  inline bool flip_orientation() const;
  inline void set_flip_orientation(bool value);
  
  // optional float object_height_width_ratio = 21 [default = 2.5];
  inline bool has_object_height_width_ratio() const;
  inline void clear_object_height_width_ratio();
  static const int kObjectHeightWidthRatioFieldNumber = 21;
  inline float object_height_width_ratio() const;
  inline void set_object_height_width_ratio(float value);
  
  // optional bool compute_part_marginals = 22 [default = true];
  inline bool has_compute_part_marginals() const;
  inline void clear_compute_part_marginals();
  static const int kComputePartMarginalsFieldNumber = 22;
  inline bool compute_part_marginals() const;
  inline void set_compute_part_marginals(bool value);
  
  // optional int32 num_pose_samples = 23 [default = 0];
  inline bool has_num_pose_samples() const;
  inline void clear_num_pose_samples();
  static const int kNumPoseSamplesFieldNumber = 23;
  inline ::google::protobuf::int32 num_pose_samples() const;
  inline void set_num_pose_samples(::google::protobuf::int32 value);
  
  // optional bool is_multicomponent = 40 [default = false];
  inline bool has_is_multicomponent() const;
  inline void clear_is_multicomponent();
  static const int kIsMulticomponentFieldNumber = 40;
  inline bool is_multicomponent() const;
  inline void set_is_multicomponent(bool value);
  
  // optional int32 num_components = 41 [default = 1];
  inline bool has_num_components() const;
  inline void clear_num_components();
  static const int kNumComponentsFieldNumber = 41;
  inline ::google::protobuf::int32 num_components() const;
  inline void set_num_components(::google::protobuf::int32 value);
  
  // optional string mix_dir = 45;
  inline bool has_mix_dir() const;
  inline void clear_mix_dir();
  static const int kMixDirFieldNumber = 45;
  inline const ::std::string& mix_dir() const;
  inline void set_mix_dir(const ::std::string& value);
  inline void set_mix_dir(const char* value);
  inline void set_mix_dir(const char* value, size_t size);
  inline ::std::string* mutable_mix_dir();
  
  // optional float strip_border_detections = 24 [default = 0];
  inline bool has_strip_border_detections() const;
  inline void clear_strip_border_detections();
  static const int kStripBorderDetectionsFieldNumber = 24;
  inline float strip_border_detections() const;
  inline void set_strip_border_detections(float value);
  
  // optional bool save_image_scoregrid = 25 [default = false];
  inline bool has_save_image_scoregrid() const;
  inline void clear_save_image_scoregrid();
  static const int kSaveImageScoregridFieldNumber = 25;
  inline bool save_image_scoregrid() const;
  inline void set_save_image_scoregrid(bool value);
  
  // optional int32 dai_num_samples = 28 [default = 1000];
  inline bool has_dai_num_samples() const;
  inline void clear_dai_num_samples();
  static const int kDaiNumSamplesFieldNumber = 28;
  inline ::google::protobuf::int32 dai_num_samples() const;
  inline void set_dai_num_samples(::google::protobuf::int32 value);
  
  // optional string dai_factors = 29 [default = ""];
  inline bool has_dai_factors() const;
  inline void clear_dai_factors();
  static const int kDaiFactorsFieldNumber = 29;
  inline const ::std::string& dai_factors() const;
  inline void set_dai_factors(const ::std::string& value);
  inline void set_dai_factors(const char* value);
  inline void set_dai_factors(const char* value, size_t size);
  inline ::std::string* mutable_dai_factors();
  
  // optional string dai_samples_dir = 30 [default = ""];
  inline bool has_dai_samples_dir() const;
  inline void clear_dai_samples_dir();
  static const int kDaiSamplesDirFieldNumber = 30;
  inline const ::std::string& dai_samples_dir() const;
  inline void set_dai_samples_dir(const ::std::string& value);
  inline void set_dai_samples_dir(const char* value);
  inline void set_dai_samples_dir(const char* value, size_t size);
  inline ::std::string* mutable_dai_samples_dir();
  
  // optional string dai_bp_type = 31 [default = "sumprod"];
  inline bool has_dai_bp_type() const;
  inline void clear_dai_bp_type();
  static const int kDaiBpTypeFieldNumber = 31;
  inline const ::std::string& dai_bp_type() const;
  inline void set_dai_bp_type(const ::std::string& value);
  inline void set_dai_bp_type(const char* value);
  inline void set_dai_bp_type(const char* value, size_t size);
  inline ::std::string* mutable_dai_bp_type();
  
  // optional string dai_samples_type = 34 [default = "part_post"];
  inline bool has_dai_samples_type() const;
  inline void clear_dai_samples_type();
  static const int kDaiSamplesTypeFieldNumber = 34;
  inline const ::std::string& dai_samples_type() const;
  inline void set_dai_samples_type(const ::std::string& value);
  inline void set_dai_samples_type(const char* value);
  inline void set_dai_samples_type(const char* value, size_t size);
  inline ::std::string* mutable_dai_samples_type();
  
  // optional bool dai_bbox_prior = 35 [default = false];
  inline bool has_dai_bbox_prior() const;
  inline void clear_dai_bbox_prior();
  static const int kDaiBboxPriorFieldNumber = 35;
  inline bool dai_bbox_prior() const;
  inline void set_dai_bbox_prior(bool value);
  
  // optional bool dai_bbox_prior_annopoints = 37 [default = false];
  inline bool has_dai_bbox_prior_annopoints() const;
  inline void clear_dai_bbox_prior_annopoints();
  static const int kDaiBboxPriorAnnopointsFieldNumber = 37;
  inline bool dai_bbox_prior_annopoints() const;
  inline void set_dai_bbox_prior_annopoints(bool value);
  
  // optional bool dai_multiperson = 36 [default = false];
  inline bool has_dai_multiperson() const;
  inline void clear_dai_multiperson();
  static const int kDaiMultipersonFieldNumber = 36;
  inline bool dai_multiperson() const;
  inline void set_dai_multiperson(bool value);
  
  // optional string detection_masks_dir = 38 [default = ""];
  inline bool has_detection_masks_dir() const;
  inline void clear_detection_masks_dir();
  static const int kDetectionMasksDirFieldNumber = 38;
  inline const ::std::string& detection_masks_dir() const;
  inline void set_detection_masks_dir(const ::std::string& value);
  inline void set_detection_masks_dir(const char* value);
  inline void set_detection_masks_dir(const char* value, size_t size);
  inline ::std::string* mutable_detection_masks_dir();
  
  // optional string roi_annolist = 42 [default = ""];
  inline bool has_roi_annolist() const;
  inline void clear_roi_annolist();
  static const int kRoiAnnolistFieldNumber = 42;
  inline const ::std::string& roi_annolist() const;
  inline void set_roi_annolist(const ::std::string& value);
  inline void set_roi_annolist(const char* value);
  inline void set_roi_annolist(const char* value, size_t size);
  inline ::std::string* mutable_roi_annolist();
  
  // optional int32 roi_extend_x = 46 [default = -1];
  inline bool has_roi_extend_x() const;
  inline void clear_roi_extend_x();
  static const int kRoiExtendXFieldNumber = 46;
  inline ::google::protobuf::int32 roi_extend_x() const;
  inline void set_roi_extend_x(::google::protobuf::int32 value);
  
  // optional int32 roi_extend_y = 47 [default = -1];
  inline bool has_roi_extend_y() const;
  inline void clear_roi_extend_y();
  static const int kRoiExtendYFieldNumber = 47;
  inline ::google::protobuf::int32 roi_extend_y() const;
  inline void set_roi_extend_y(::google::protobuf::int32 value);
  
  // optional float roi_save_num_samples = 48 [default = 1000];
  inline bool has_roi_save_num_samples() const;
  inline void clear_roi_save_num_samples();
  static const int kRoiSaveNumSamplesFieldNumber = 48;
  inline float roi_save_num_samples() const;
  inline void set_roi_save_num_samples(float value);
  
  // optional bool compute_max = 43 [default = false];
  inline bool has_compute_max() const;
  inline void clear_compute_max();
  static const int kComputeMaxFieldNumber = 43;
  inline bool compute_max() const;
  inline void set_compute_max(bool value);
  
  // optional bool reweight_inference = 53 [default = false];
  inline bool has_reweight_inference() const;
  inline void clear_reweight_inference();
  static const int kReweightInferenceFieldNumber = 53;
  inline bool reweight_inference() const;
  inline void set_reweight_inference(bool value);
  
  // optional bool save_root_marginal = 136 [default = false];
  inline bool has_save_root_marginal() const;
  inline void clear_save_root_marginal();
  static const int kSaveRootMarginalFieldNumber = 136;
  inline bool save_root_marginal() const;
  inline void set_save_root_marginal(bool value);
  
  // @@protoc_insertion_point(class_scope:ExpParam)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> train_dataset_;
  ::google::protobuf::RepeatedPtrField< ::std::string> validation_dataset_;
  ::google::protobuf::RepeatedPtrField< ::std::string> test_dataset_;
  ::google::protobuf::RepeatedPtrField< ::std::string> neg_dataset_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bootstrap_dataset_;
  ::google::protobuf::RepeatedPtrField< ::std::string> train_dataset_reshaped_;
  ::std::string* log_dir_;
  static const ::std::string _default_log_dir_;
  ::std::string* log_subdir_;
  static const ::std::string _default_log_subdir_;
  ::std::string* class_dir_;
  static const ::std::string _default_class_dir_;
  ::google::protobuf::RepeatedPtrField< ::std::string> comp_class_dir_;
  ::std::string* scoregrid_dir_;
  static const ::std::string _default_scoregrid_dir_;
  ::std::string* scoregrid_train_dir_;
  static const ::std::string _default_scoregrid_train_dir_;
  bool normalize_kmeans_;
  ::google::protobuf::uint32 ndim_joint_;
  ::google::protobuf::uint32 poselet_strip_;
  float vis_weight_;
  float vp_weight_;
  float bootstrap_threshold_;
  ::google::protobuf::int32 num_best_part_det_vis_;
  float min_clus_size_;
  bool pred_unary_rot_;
  float pred_unary_pos_weight_;
  float pred_unary_rot_weight_;
  ::google::protobuf::uint32 pred_unary_rot_comp_;
  ::std::string* pred_data_dir_;
  static const ::std::string _default_pred_data_dir_;
  ::std::string* pred_data_test_dir_;
  static const ::std::string _default_pred_data_test_dir_;
  ::std::string* poselet_resp_val_dir_;
  static const ::std::string _default_poselet_resp_val_dir_;
  ::std::string* poselet_resp_test_dir_;
  static const ::std::string _default_poselet_resp_test_dir_;
  ::std::string* spatial_dir_;
  static const ::std::string _default_spatial_dir_;
  float dpm_torso_weight_;
  bool force_recompute_scores_;
  float torso_pos_prior_weight_;
  ::std::string* torso_det_test_dir_;
  static const ::std::string _default_torso_det_test_dir_;
  ::std::string* torso_det_train_dir_;
  static const ::std::string _default_torso_det_train_dir_;
  ::google::protobuf::uint32 poselet_rot_strip_;
  ::google::protobuf::uint32 rootidx_det_;
  bool use_gt_torso_;
  bool use_dpm_torso_;
  bool pred_unary_pos_;
  bool use_torso_pos_prior_;
  bool use_dpm_head_;
  float dpm_head_weight_;
  ::std::string* test_dpm_unary_dir_;
  static const ::std::string _default_test_dpm_unary_dir_;
  float dpm_unary_weight_;
  bool use_dpm_unary_;
  bool do_dpm_rot_;
  bool use_pairwise_;
  bool save_part_marginals_;
  ::std::string* dpm_model_dir_;
  static const ::std::string _default_dpm_model_dir_;
  float unary_weight_;
  bool interpolate_;
  ::std::string* pos_dpm_torso_dir_;
  static const ::std::string _default_pos_dpm_torso_dir_;
  ::std::string* test_dpm_torso_dir_;
  static const ::std::string _default_test_dpm_torso_dir_;
  ::google::protobuf::uint32 torso_hyp_idx_;
  ::std::string* part_marginals_dir_;
  static const ::std::string _default_part_marginals_dir_;
  ::std::string* part_conf_;
  static const ::std::string _default_part_conf_;
  ::std::string* part_conf_eval_;
  static const ::std::string _default_part_conf_eval_;
  ::std::string* part_conf_type_;
  static const ::std::string _default_part_conf_type_;
  ::std::string* abc_param_;
  static const ::std::string _default_abc_param_;
  float min_object_scale_;
  float max_object_scale_;
  ::google::protobuf::uint32 num_scale_steps_;
  float min_part_rotation_;
  float max_part_rotation_;
  ::google::protobuf::uint32 num_rotation_steps_;
  bool flip_orientation_;
  float object_height_width_ratio_;
  bool compute_part_marginals_;
  ::google::protobuf::int32 num_pose_samples_;
  bool is_multicomponent_;
  ::google::protobuf::int32 num_components_;
  ::std::string* mix_dir_;
  static const ::std::string _default_mix_dir_;
  float strip_border_detections_;
  bool save_image_scoregrid_;
  ::google::protobuf::int32 dai_num_samples_;
  ::std::string* dai_factors_;
  static const ::std::string _default_dai_factors_;
  ::std::string* dai_samples_dir_;
  static const ::std::string _default_dai_samples_dir_;
  ::std::string* dai_bp_type_;
  static const ::std::string _default_dai_bp_type_;
  ::std::string* dai_samples_type_;
  static const ::std::string _default_dai_samples_type_;
  bool dai_bbox_prior_;
  bool dai_bbox_prior_annopoints_;
  bool dai_multiperson_;
  ::std::string* detection_masks_dir_;
  static const ::std::string _default_detection_masks_dir_;
  ::std::string* roi_annolist_;
  static const ::std::string _default_roi_annolist_;
  ::google::protobuf::int32 roi_extend_x_;
  ::google::protobuf::int32 roi_extend_y_;
  float roi_save_num_samples_;
  bool compute_max_;
  bool reweight_inference_;
  bool save_root_marginal_;
  friend void  protobuf_AddDesc_ExpParam_2eproto();
  friend void protobuf_AssignDesc_ExpParam_2eproto();
  friend void protobuf_ShutdownFile_ExpParam_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(90 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ExpParam* default_instance_;
};
// ===================================================================


// ===================================================================

// ExpParam

// repeated string train_dataset = 1;
inline int ExpParam::train_dataset_size() const {
  return train_dataset_.size();
}
inline void ExpParam::clear_train_dataset() {
  train_dataset_.Clear();
}
inline const ::std::string& ExpParam::train_dataset(int index) const {
  return train_dataset_.Get(index);
}
inline ::std::string* ExpParam::mutable_train_dataset(int index) {
  return train_dataset_.Mutable(index);
}
inline void ExpParam::set_train_dataset(int index, const ::std::string& value) {
  train_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_train_dataset(int index, const char* value) {
  train_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_train_dataset(int index, const char* value, size_t size) {
  train_dataset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_train_dataset() {
  return train_dataset_.Add();
}
inline void ExpParam::add_train_dataset(const ::std::string& value) {
  train_dataset_.Add()->assign(value);
}
inline void ExpParam::add_train_dataset(const char* value) {
  train_dataset_.Add()->assign(value);
}
inline void ExpParam::add_train_dataset(const char* value, size_t size) {
  train_dataset_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::train_dataset() const {
  return train_dataset_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_train_dataset() {
  return &train_dataset_;
}

// repeated string validation_dataset = 8;
inline int ExpParam::validation_dataset_size() const {
  return validation_dataset_.size();
}
inline void ExpParam::clear_validation_dataset() {
  validation_dataset_.Clear();
}
inline const ::std::string& ExpParam::validation_dataset(int index) const {
  return validation_dataset_.Get(index);
}
inline ::std::string* ExpParam::mutable_validation_dataset(int index) {
  return validation_dataset_.Mutable(index);
}
inline void ExpParam::set_validation_dataset(int index, const ::std::string& value) {
  validation_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_validation_dataset(int index, const char* value) {
  validation_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_validation_dataset(int index, const char* value, size_t size) {
  validation_dataset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_validation_dataset() {
  return validation_dataset_.Add();
}
inline void ExpParam::add_validation_dataset(const ::std::string& value) {
  validation_dataset_.Add()->assign(value);
}
inline void ExpParam::add_validation_dataset(const char* value) {
  validation_dataset_.Add()->assign(value);
}
inline void ExpParam::add_validation_dataset(const char* value, size_t size) {
  validation_dataset_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::validation_dataset() const {
  return validation_dataset_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_validation_dataset() {
  return &validation_dataset_;
}

// repeated string test_dataset = 2;
inline int ExpParam::test_dataset_size() const {
  return test_dataset_.size();
}
inline void ExpParam::clear_test_dataset() {
  test_dataset_.Clear();
}
inline const ::std::string& ExpParam::test_dataset(int index) const {
  return test_dataset_.Get(index);
}
inline ::std::string* ExpParam::mutable_test_dataset(int index) {
  return test_dataset_.Mutable(index);
}
inline void ExpParam::set_test_dataset(int index, const ::std::string& value) {
  test_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_test_dataset(int index, const char* value) {
  test_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_test_dataset(int index, const char* value, size_t size) {
  test_dataset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_test_dataset() {
  return test_dataset_.Add();
}
inline void ExpParam::add_test_dataset(const ::std::string& value) {
  test_dataset_.Add()->assign(value);
}
inline void ExpParam::add_test_dataset(const char* value) {
  test_dataset_.Add()->assign(value);
}
inline void ExpParam::add_test_dataset(const char* value, size_t size) {
  test_dataset_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::test_dataset() const {
  return test_dataset_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_test_dataset() {
  return &test_dataset_;
}

// repeated string neg_dataset = 51;
inline int ExpParam::neg_dataset_size() const {
  return neg_dataset_.size();
}
inline void ExpParam::clear_neg_dataset() {
  neg_dataset_.Clear();
}
inline const ::std::string& ExpParam::neg_dataset(int index) const {
  return neg_dataset_.Get(index);
}
inline ::std::string* ExpParam::mutable_neg_dataset(int index) {
  return neg_dataset_.Mutable(index);
}
inline void ExpParam::set_neg_dataset(int index, const ::std::string& value) {
  neg_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_neg_dataset(int index, const char* value) {
  neg_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_neg_dataset(int index, const char* value, size_t size) {
  neg_dataset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_neg_dataset() {
  return neg_dataset_.Add();
}
inline void ExpParam::add_neg_dataset(const ::std::string& value) {
  neg_dataset_.Add()->assign(value);
}
inline void ExpParam::add_neg_dataset(const char* value) {
  neg_dataset_.Add()->assign(value);
}
inline void ExpParam::add_neg_dataset(const char* value, size_t size) {
  neg_dataset_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::neg_dataset() const {
  return neg_dataset_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_neg_dataset() {
  return &neg_dataset_;
}

// repeated string bootstrap_dataset = 86;
inline int ExpParam::bootstrap_dataset_size() const {
  return bootstrap_dataset_.size();
}
inline void ExpParam::clear_bootstrap_dataset() {
  bootstrap_dataset_.Clear();
}
inline const ::std::string& ExpParam::bootstrap_dataset(int index) const {
  return bootstrap_dataset_.Get(index);
}
inline ::std::string* ExpParam::mutable_bootstrap_dataset(int index) {
  return bootstrap_dataset_.Mutable(index);
}
inline void ExpParam::set_bootstrap_dataset(int index, const ::std::string& value) {
  bootstrap_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_bootstrap_dataset(int index, const char* value) {
  bootstrap_dataset_.Mutable(index)->assign(value);
}
inline void ExpParam::set_bootstrap_dataset(int index, const char* value, size_t size) {
  bootstrap_dataset_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_bootstrap_dataset() {
  return bootstrap_dataset_.Add();
}
inline void ExpParam::add_bootstrap_dataset(const ::std::string& value) {
  bootstrap_dataset_.Add()->assign(value);
}
inline void ExpParam::add_bootstrap_dataset(const char* value) {
  bootstrap_dataset_.Add()->assign(value);
}
inline void ExpParam::add_bootstrap_dataset(const char* value, size_t size) {
  bootstrap_dataset_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::bootstrap_dataset() const {
  return bootstrap_dataset_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_bootstrap_dataset() {
  return &bootstrap_dataset_;
}

// repeated string train_dataset_reshaped = 39;
inline int ExpParam::train_dataset_reshaped_size() const {
  return train_dataset_reshaped_.size();
}
inline void ExpParam::clear_train_dataset_reshaped() {
  train_dataset_reshaped_.Clear();
}
inline const ::std::string& ExpParam::train_dataset_reshaped(int index) const {
  return train_dataset_reshaped_.Get(index);
}
inline ::std::string* ExpParam::mutable_train_dataset_reshaped(int index) {
  return train_dataset_reshaped_.Mutable(index);
}
inline void ExpParam::set_train_dataset_reshaped(int index, const ::std::string& value) {
  train_dataset_reshaped_.Mutable(index)->assign(value);
}
inline void ExpParam::set_train_dataset_reshaped(int index, const char* value) {
  train_dataset_reshaped_.Mutable(index)->assign(value);
}
inline void ExpParam::set_train_dataset_reshaped(int index, const char* value, size_t size) {
  train_dataset_reshaped_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_train_dataset_reshaped() {
  return train_dataset_reshaped_.Add();
}
inline void ExpParam::add_train_dataset_reshaped(const ::std::string& value) {
  train_dataset_reshaped_.Add()->assign(value);
}
inline void ExpParam::add_train_dataset_reshaped(const char* value) {
  train_dataset_reshaped_.Add()->assign(value);
}
inline void ExpParam::add_train_dataset_reshaped(const char* value, size_t size) {
  train_dataset_reshaped_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::train_dataset_reshaped() const {
  return train_dataset_reshaped_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_train_dataset_reshaped() {
  return &train_dataset_reshaped_;
}

// optional string log_dir = 3;
inline bool ExpParam::has_log_dir() const {
  return _has_bit(6);
}
inline void ExpParam::clear_log_dir() {
  if (log_dir_ != &_default_log_dir_) {
    log_dir_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& ExpParam::log_dir() const {
  return *log_dir_;
}
inline void ExpParam::set_log_dir(const ::std::string& value) {
  _set_bit(6);
  if (log_dir_ == &_default_log_dir_) {
    log_dir_ = new ::std::string;
  }
  log_dir_->assign(value);
}
inline void ExpParam::set_log_dir(const char* value) {
  _set_bit(6);
  if (log_dir_ == &_default_log_dir_) {
    log_dir_ = new ::std::string;
  }
  log_dir_->assign(value);
}
inline void ExpParam::set_log_dir(const char* value, size_t size) {
  _set_bit(6);
  if (log_dir_ == &_default_log_dir_) {
    log_dir_ = new ::std::string;
  }
  log_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_log_dir() {
  _set_bit(6);
  if (log_dir_ == &_default_log_dir_) {
    log_dir_ = new ::std::string;
  }
  return log_dir_;
}

// optional string log_subdir = 7;
inline bool ExpParam::has_log_subdir() const {
  return _has_bit(7);
}
inline void ExpParam::clear_log_subdir() {
  if (log_subdir_ != &_default_log_subdir_) {
    log_subdir_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& ExpParam::log_subdir() const {
  return *log_subdir_;
}
inline void ExpParam::set_log_subdir(const ::std::string& value) {
  _set_bit(7);
  if (log_subdir_ == &_default_log_subdir_) {
    log_subdir_ = new ::std::string;
  }
  log_subdir_->assign(value);
}
inline void ExpParam::set_log_subdir(const char* value) {
  _set_bit(7);
  if (log_subdir_ == &_default_log_subdir_) {
    log_subdir_ = new ::std::string;
  }
  log_subdir_->assign(value);
}
inline void ExpParam::set_log_subdir(const char* value, size_t size) {
  _set_bit(7);
  if (log_subdir_ == &_default_log_subdir_) {
    log_subdir_ = new ::std::string;
  }
  log_subdir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_log_subdir() {
  _set_bit(7);
  if (log_subdir_ == &_default_log_subdir_) {
    log_subdir_ = new ::std::string;
  }
  return log_subdir_;
}

// optional string class_dir = 4;
inline bool ExpParam::has_class_dir() const {
  return _has_bit(8);
}
inline void ExpParam::clear_class_dir() {
  if (class_dir_ != &_default_class_dir_) {
    class_dir_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& ExpParam::class_dir() const {
  return *class_dir_;
}
inline void ExpParam::set_class_dir(const ::std::string& value) {
  _set_bit(8);
  if (class_dir_ == &_default_class_dir_) {
    class_dir_ = new ::std::string;
  }
  class_dir_->assign(value);
}
inline void ExpParam::set_class_dir(const char* value) {
  _set_bit(8);
  if (class_dir_ == &_default_class_dir_) {
    class_dir_ = new ::std::string;
  }
  class_dir_->assign(value);
}
inline void ExpParam::set_class_dir(const char* value, size_t size) {
  _set_bit(8);
  if (class_dir_ == &_default_class_dir_) {
    class_dir_ = new ::std::string;
  }
  class_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_class_dir() {
  _set_bit(8);
  if (class_dir_ == &_default_class_dir_) {
    class_dir_ = new ::std::string;
  }
  return class_dir_;
}

// repeated string comp_class_dir = 50;
inline int ExpParam::comp_class_dir_size() const {
  return comp_class_dir_.size();
}
inline void ExpParam::clear_comp_class_dir() {
  comp_class_dir_.Clear();
}
inline const ::std::string& ExpParam::comp_class_dir(int index) const {
  return comp_class_dir_.Get(index);
}
inline ::std::string* ExpParam::mutable_comp_class_dir(int index) {
  return comp_class_dir_.Mutable(index);
}
inline void ExpParam::set_comp_class_dir(int index, const ::std::string& value) {
  comp_class_dir_.Mutable(index)->assign(value);
}
inline void ExpParam::set_comp_class_dir(int index, const char* value) {
  comp_class_dir_.Mutable(index)->assign(value);
}
inline void ExpParam::set_comp_class_dir(int index, const char* value, size_t size) {
  comp_class_dir_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::add_comp_class_dir() {
  return comp_class_dir_.Add();
}
inline void ExpParam::add_comp_class_dir(const ::std::string& value) {
  comp_class_dir_.Add()->assign(value);
}
inline void ExpParam::add_comp_class_dir(const char* value) {
  comp_class_dir_.Add()->assign(value);
}
inline void ExpParam::add_comp_class_dir(const char* value, size_t size) {
  comp_class_dir_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpParam::comp_class_dir() const {
  return comp_class_dir_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpParam::mutable_comp_class_dir() {
  return &comp_class_dir_;
}

// optional string scoregrid_dir = 16;
inline bool ExpParam::has_scoregrid_dir() const {
  return _has_bit(10);
}
inline void ExpParam::clear_scoregrid_dir() {
  if (scoregrid_dir_ != &_default_scoregrid_dir_) {
    scoregrid_dir_->clear();
  }
  _clear_bit(10);
}
inline const ::std::string& ExpParam::scoregrid_dir() const {
  return *scoregrid_dir_;
}
inline void ExpParam::set_scoregrid_dir(const ::std::string& value) {
  _set_bit(10);
  if (scoregrid_dir_ == &_default_scoregrid_dir_) {
    scoregrid_dir_ = new ::std::string;
  }
  scoregrid_dir_->assign(value);
}
inline void ExpParam::set_scoregrid_dir(const char* value) {
  _set_bit(10);
  if (scoregrid_dir_ == &_default_scoregrid_dir_) {
    scoregrid_dir_ = new ::std::string;
  }
  scoregrid_dir_->assign(value);
}
inline void ExpParam::set_scoregrid_dir(const char* value, size_t size) {
  _set_bit(10);
  if (scoregrid_dir_ == &_default_scoregrid_dir_) {
    scoregrid_dir_ = new ::std::string;
  }
  scoregrid_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_scoregrid_dir() {
  _set_bit(10);
  if (scoregrid_dir_ == &_default_scoregrid_dir_) {
    scoregrid_dir_ = new ::std::string;
  }
  return scoregrid_dir_;
}

// optional string scoregrid_train_dir = 44;
inline bool ExpParam::has_scoregrid_train_dir() const {
  return _has_bit(11);
}
inline void ExpParam::clear_scoregrid_train_dir() {
  if (scoregrid_train_dir_ != &_default_scoregrid_train_dir_) {
    scoregrid_train_dir_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& ExpParam::scoregrid_train_dir() const {
  return *scoregrid_train_dir_;
}
inline void ExpParam::set_scoregrid_train_dir(const ::std::string& value) {
  _set_bit(11);
  if (scoregrid_train_dir_ == &_default_scoregrid_train_dir_) {
    scoregrid_train_dir_ = new ::std::string;
  }
  scoregrid_train_dir_->assign(value);
}
inline void ExpParam::set_scoregrid_train_dir(const char* value) {
  _set_bit(11);
  if (scoregrid_train_dir_ == &_default_scoregrid_train_dir_) {
    scoregrid_train_dir_ = new ::std::string;
  }
  scoregrid_train_dir_->assign(value);
}
inline void ExpParam::set_scoregrid_train_dir(const char* value, size_t size) {
  _set_bit(11);
  if (scoregrid_train_dir_ == &_default_scoregrid_train_dir_) {
    scoregrid_train_dir_ = new ::std::string;
  }
  scoregrid_train_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_scoregrid_train_dir() {
  _set_bit(11);
  if (scoregrid_train_dir_ == &_default_scoregrid_train_dir_) {
    scoregrid_train_dir_ = new ::std::string;
  }
  return scoregrid_train_dir_;
}

// optional bool normalize_kmeans = 81 [default = false];
inline bool ExpParam::has_normalize_kmeans() const {
  return _has_bit(12);
}
inline void ExpParam::clear_normalize_kmeans() {
  normalize_kmeans_ = false;
  _clear_bit(12);
}
inline bool ExpParam::normalize_kmeans() const {
  return normalize_kmeans_;
}
inline void ExpParam::set_normalize_kmeans(bool value) {
  _set_bit(12);
  normalize_kmeans_ = value;
}

// optional uint32 ndim_joint = 82 [default = 2];
inline bool ExpParam::has_ndim_joint() const {
  return _has_bit(13);
}
inline void ExpParam::clear_ndim_joint() {
  ndim_joint_ = 2u;
  _clear_bit(13);
}
inline ::google::protobuf::uint32 ExpParam::ndim_joint() const {
  return ndim_joint_;
}
inline void ExpParam::set_ndim_joint(::google::protobuf::uint32 value) {
  _set_bit(13);
  ndim_joint_ = value;
}

// optional uint32 poselet_strip = 83 [default = 40];
inline bool ExpParam::has_poselet_strip() const {
  return _has_bit(14);
}
inline void ExpParam::clear_poselet_strip() {
  poselet_strip_ = 40u;
  _clear_bit(14);
}
inline ::google::protobuf::uint32 ExpParam::poselet_strip() const {
  return poselet_strip_;
}
inline void ExpParam::set_poselet_strip(::google::protobuf::uint32 value) {
  _set_bit(14);
  poselet_strip_ = value;
}

// optional float vis_weight = 84 [default = 0];
inline bool ExpParam::has_vis_weight() const {
  return _has_bit(15);
}
inline void ExpParam::clear_vis_weight() {
  vis_weight_ = 0;
  _clear_bit(15);
}
inline float ExpParam::vis_weight() const {
  return vis_weight_;
}
inline void ExpParam::set_vis_weight(float value) {
  _set_bit(15);
  vis_weight_ = value;
}

// optional float vp_weight = 85 [default = 0];
inline bool ExpParam::has_vp_weight() const {
  return _has_bit(16);
}
inline void ExpParam::clear_vp_weight() {
  vp_weight_ = 0;
  _clear_bit(16);
}
inline float ExpParam::vp_weight() const {
  return vp_weight_;
}
inline void ExpParam::set_vp_weight(float value) {
  _set_bit(16);
  vp_weight_ = value;
}

// optional float bootstrap_threshold = 88 [default = 0.3];
inline bool ExpParam::has_bootstrap_threshold() const {
  return _has_bit(17);
}
inline void ExpParam::clear_bootstrap_threshold() {
  bootstrap_threshold_ = 0.3f;
  _clear_bit(17);
}
inline float ExpParam::bootstrap_threshold() const {
  return bootstrap_threshold_;
}
inline void ExpParam::set_bootstrap_threshold(float value) {
  _set_bit(17);
  bootstrap_threshold_ = value;
}

// optional int32 num_best_part_det_vis = 90 [default = 1];
inline bool ExpParam::has_num_best_part_det_vis() const {
  return _has_bit(18);
}
inline void ExpParam::clear_num_best_part_det_vis() {
  num_best_part_det_vis_ = 1;
  _clear_bit(18);
}
inline ::google::protobuf::int32 ExpParam::num_best_part_det_vis() const {
  return num_best_part_det_vis_;
}
inline void ExpParam::set_num_best_part_det_vis(::google::protobuf::int32 value) {
  _set_bit(18);
  num_best_part_det_vis_ = value;
}

// optional float min_clus_size = 92 [default = 10];
inline bool ExpParam::has_min_clus_size() const {
  return _has_bit(19);
}
inline void ExpParam::clear_min_clus_size() {
  min_clus_size_ = 10;
  _clear_bit(19);
}
inline float ExpParam::min_clus_size() const {
  return min_clus_size_;
}
inline void ExpParam::set_min_clus_size(float value) {
  _set_bit(19);
  min_clus_size_ = value;
}

// optional bool pred_unary_rot = 93 [default = false];
inline bool ExpParam::has_pred_unary_rot() const {
  return _has_bit(20);
}
inline void ExpParam::clear_pred_unary_rot() {
  pred_unary_rot_ = false;
  _clear_bit(20);
}
inline bool ExpParam::pred_unary_rot() const {
  return pred_unary_rot_;
}
inline void ExpParam::set_pred_unary_rot(bool value) {
  _set_bit(20);
  pred_unary_rot_ = value;
}

// optional float pred_unary_pos_weight = 95 [default = 1];
inline bool ExpParam::has_pred_unary_pos_weight() const {
  return _has_bit(21);
}
inline void ExpParam::clear_pred_unary_pos_weight() {
  pred_unary_pos_weight_ = 1;
  _clear_bit(21);
}
inline float ExpParam::pred_unary_pos_weight() const {
  return pred_unary_pos_weight_;
}
inline void ExpParam::set_pred_unary_pos_weight(float value) {
  _set_bit(21);
  pred_unary_pos_weight_ = value;
}

// optional float pred_unary_rot_weight = 96 [default = 1];
inline bool ExpParam::has_pred_unary_rot_weight() const {
  return _has_bit(22);
}
inline void ExpParam::clear_pred_unary_rot_weight() {
  pred_unary_rot_weight_ = 1;
  _clear_bit(22);
}
inline float ExpParam::pred_unary_rot_weight() const {
  return pred_unary_rot_weight_;
}
inline void ExpParam::set_pred_unary_rot_weight(float value) {
  _set_bit(22);
  pred_unary_rot_weight_ = value;
}

// optional uint32 pred_unary_rot_comp = 97 [default = 1];
inline bool ExpParam::has_pred_unary_rot_comp() const {
  return _has_bit(23);
}
inline void ExpParam::clear_pred_unary_rot_comp() {
  pred_unary_rot_comp_ = 1u;
  _clear_bit(23);
}
inline ::google::protobuf::uint32 ExpParam::pred_unary_rot_comp() const {
  return pred_unary_rot_comp_;
}
inline void ExpParam::set_pred_unary_rot_comp(::google::protobuf::uint32 value) {
  _set_bit(23);
  pred_unary_rot_comp_ = value;
}

// optional string pred_data_dir = 98;
inline bool ExpParam::has_pred_data_dir() const {
  return _has_bit(24);
}
inline void ExpParam::clear_pred_data_dir() {
  if (pred_data_dir_ != &_default_pred_data_dir_) {
    pred_data_dir_->clear();
  }
  _clear_bit(24);
}
inline const ::std::string& ExpParam::pred_data_dir() const {
  return *pred_data_dir_;
}
inline void ExpParam::set_pred_data_dir(const ::std::string& value) {
  _set_bit(24);
  if (pred_data_dir_ == &_default_pred_data_dir_) {
    pred_data_dir_ = new ::std::string;
  }
  pred_data_dir_->assign(value);
}
inline void ExpParam::set_pred_data_dir(const char* value) {
  _set_bit(24);
  if (pred_data_dir_ == &_default_pred_data_dir_) {
    pred_data_dir_ = new ::std::string;
  }
  pred_data_dir_->assign(value);
}
inline void ExpParam::set_pred_data_dir(const char* value, size_t size) {
  _set_bit(24);
  if (pred_data_dir_ == &_default_pred_data_dir_) {
    pred_data_dir_ = new ::std::string;
  }
  pred_data_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_pred_data_dir() {
  _set_bit(24);
  if (pred_data_dir_ == &_default_pred_data_dir_) {
    pred_data_dir_ = new ::std::string;
  }
  return pred_data_dir_;
}

// optional string pred_data_test_dir = 135;
inline bool ExpParam::has_pred_data_test_dir() const {
  return _has_bit(25);
}
inline void ExpParam::clear_pred_data_test_dir() {
  if (pred_data_test_dir_ != &_default_pred_data_test_dir_) {
    pred_data_test_dir_->clear();
  }
  _clear_bit(25);
}
inline const ::std::string& ExpParam::pred_data_test_dir() const {
  return *pred_data_test_dir_;
}
inline void ExpParam::set_pred_data_test_dir(const ::std::string& value) {
  _set_bit(25);
  if (pred_data_test_dir_ == &_default_pred_data_test_dir_) {
    pred_data_test_dir_ = new ::std::string;
  }
  pred_data_test_dir_->assign(value);
}
inline void ExpParam::set_pred_data_test_dir(const char* value) {
  _set_bit(25);
  if (pred_data_test_dir_ == &_default_pred_data_test_dir_) {
    pred_data_test_dir_ = new ::std::string;
  }
  pred_data_test_dir_->assign(value);
}
inline void ExpParam::set_pred_data_test_dir(const char* value, size_t size) {
  _set_bit(25);
  if (pred_data_test_dir_ == &_default_pred_data_test_dir_) {
    pred_data_test_dir_ = new ::std::string;
  }
  pred_data_test_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_pred_data_test_dir() {
  _set_bit(25);
  if (pred_data_test_dir_ == &_default_pred_data_test_dir_) {
    pred_data_test_dir_ = new ::std::string;
  }
  return pred_data_test_dir_;
}

// optional string poselet_resp_val_dir = 137;
inline bool ExpParam::has_poselet_resp_val_dir() const {
  return _has_bit(26);
}
inline void ExpParam::clear_poselet_resp_val_dir() {
  if (poselet_resp_val_dir_ != &_default_poselet_resp_val_dir_) {
    poselet_resp_val_dir_->clear();
  }
  _clear_bit(26);
}
inline const ::std::string& ExpParam::poselet_resp_val_dir() const {
  return *poselet_resp_val_dir_;
}
inline void ExpParam::set_poselet_resp_val_dir(const ::std::string& value) {
  _set_bit(26);
  if (poselet_resp_val_dir_ == &_default_poselet_resp_val_dir_) {
    poselet_resp_val_dir_ = new ::std::string;
  }
  poselet_resp_val_dir_->assign(value);
}
inline void ExpParam::set_poselet_resp_val_dir(const char* value) {
  _set_bit(26);
  if (poselet_resp_val_dir_ == &_default_poselet_resp_val_dir_) {
    poselet_resp_val_dir_ = new ::std::string;
  }
  poselet_resp_val_dir_->assign(value);
}
inline void ExpParam::set_poselet_resp_val_dir(const char* value, size_t size) {
  _set_bit(26);
  if (poselet_resp_val_dir_ == &_default_poselet_resp_val_dir_) {
    poselet_resp_val_dir_ = new ::std::string;
  }
  poselet_resp_val_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_poselet_resp_val_dir() {
  _set_bit(26);
  if (poselet_resp_val_dir_ == &_default_poselet_resp_val_dir_) {
    poselet_resp_val_dir_ = new ::std::string;
  }
  return poselet_resp_val_dir_;
}

// optional string poselet_resp_test_dir = 138;
inline bool ExpParam::has_poselet_resp_test_dir() const {
  return _has_bit(27);
}
inline void ExpParam::clear_poselet_resp_test_dir() {
  if (poselet_resp_test_dir_ != &_default_poselet_resp_test_dir_) {
    poselet_resp_test_dir_->clear();
  }
  _clear_bit(27);
}
inline const ::std::string& ExpParam::poselet_resp_test_dir() const {
  return *poselet_resp_test_dir_;
}
inline void ExpParam::set_poselet_resp_test_dir(const ::std::string& value) {
  _set_bit(27);
  if (poselet_resp_test_dir_ == &_default_poselet_resp_test_dir_) {
    poselet_resp_test_dir_ = new ::std::string;
  }
  poselet_resp_test_dir_->assign(value);
}
inline void ExpParam::set_poselet_resp_test_dir(const char* value) {
  _set_bit(27);
  if (poselet_resp_test_dir_ == &_default_poselet_resp_test_dir_) {
    poselet_resp_test_dir_ = new ::std::string;
  }
  poselet_resp_test_dir_->assign(value);
}
inline void ExpParam::set_poselet_resp_test_dir(const char* value, size_t size) {
  _set_bit(27);
  if (poselet_resp_test_dir_ == &_default_poselet_resp_test_dir_) {
    poselet_resp_test_dir_ = new ::std::string;
  }
  poselet_resp_test_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_poselet_resp_test_dir() {
  _set_bit(27);
  if (poselet_resp_test_dir_ == &_default_poselet_resp_test_dir_) {
    poselet_resp_test_dir_ = new ::std::string;
  }
  return poselet_resp_test_dir_;
}

// optional string spatial_dir = 139;
inline bool ExpParam::has_spatial_dir() const {
  return _has_bit(28);
}
inline void ExpParam::clear_spatial_dir() {
  if (spatial_dir_ != &_default_spatial_dir_) {
    spatial_dir_->clear();
  }
  _clear_bit(28);
}
inline const ::std::string& ExpParam::spatial_dir() const {
  return *spatial_dir_;
}
inline void ExpParam::set_spatial_dir(const ::std::string& value) {
  _set_bit(28);
  if (spatial_dir_ == &_default_spatial_dir_) {
    spatial_dir_ = new ::std::string;
  }
  spatial_dir_->assign(value);
}
inline void ExpParam::set_spatial_dir(const char* value) {
  _set_bit(28);
  if (spatial_dir_ == &_default_spatial_dir_) {
    spatial_dir_ = new ::std::string;
  }
  spatial_dir_->assign(value);
}
inline void ExpParam::set_spatial_dir(const char* value, size_t size) {
  _set_bit(28);
  if (spatial_dir_ == &_default_spatial_dir_) {
    spatial_dir_ = new ::std::string;
  }
  spatial_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_spatial_dir() {
  _set_bit(28);
  if (spatial_dir_ == &_default_spatial_dir_) {
    spatial_dir_ = new ::std::string;
  }
  return spatial_dir_;
}

// optional float dpm_torso_weight = 99 [default = 1];
inline bool ExpParam::has_dpm_torso_weight() const {
  return _has_bit(29);
}
inline void ExpParam::clear_dpm_torso_weight() {
  dpm_torso_weight_ = 1;
  _clear_bit(29);
}
inline float ExpParam::dpm_torso_weight() const {
  return dpm_torso_weight_;
}
inline void ExpParam::set_dpm_torso_weight(float value) {
  _set_bit(29);
  dpm_torso_weight_ = value;
}

// optional bool force_recompute_scores = 101 [default = true];
inline bool ExpParam::has_force_recompute_scores() const {
  return _has_bit(30);
}
inline void ExpParam::clear_force_recompute_scores() {
  force_recompute_scores_ = true;
  _clear_bit(30);
}
inline bool ExpParam::force_recompute_scores() const {
  return force_recompute_scores_;
}
inline void ExpParam::set_force_recompute_scores(bool value) {
  _set_bit(30);
  force_recompute_scores_ = value;
}

// optional float torso_pos_prior_weight = 105 [default = 1];
inline bool ExpParam::has_torso_pos_prior_weight() const {
  return _has_bit(31);
}
inline void ExpParam::clear_torso_pos_prior_weight() {
  torso_pos_prior_weight_ = 1;
  _clear_bit(31);
}
inline float ExpParam::torso_pos_prior_weight() const {
  return torso_pos_prior_weight_;
}
inline void ExpParam::set_torso_pos_prior_weight(float value) {
  _set_bit(31);
  torso_pos_prior_weight_ = value;
}

// optional string torso_det_test_dir = 107;
inline bool ExpParam::has_torso_det_test_dir() const {
  return _has_bit(32);
}
inline void ExpParam::clear_torso_det_test_dir() {
  if (torso_det_test_dir_ != &_default_torso_det_test_dir_) {
    torso_det_test_dir_->clear();
  }
  _clear_bit(32);
}
inline const ::std::string& ExpParam::torso_det_test_dir() const {
  return *torso_det_test_dir_;
}
inline void ExpParam::set_torso_det_test_dir(const ::std::string& value) {
  _set_bit(32);
  if (torso_det_test_dir_ == &_default_torso_det_test_dir_) {
    torso_det_test_dir_ = new ::std::string;
  }
  torso_det_test_dir_->assign(value);
}
inline void ExpParam::set_torso_det_test_dir(const char* value) {
  _set_bit(32);
  if (torso_det_test_dir_ == &_default_torso_det_test_dir_) {
    torso_det_test_dir_ = new ::std::string;
  }
  torso_det_test_dir_->assign(value);
}
inline void ExpParam::set_torso_det_test_dir(const char* value, size_t size) {
  _set_bit(32);
  if (torso_det_test_dir_ == &_default_torso_det_test_dir_) {
    torso_det_test_dir_ = new ::std::string;
  }
  torso_det_test_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_torso_det_test_dir() {
  _set_bit(32);
  if (torso_det_test_dir_ == &_default_torso_det_test_dir_) {
    torso_det_test_dir_ = new ::std::string;
  }
  return torso_det_test_dir_;
}

// optional string torso_det_train_dir = 108;
inline bool ExpParam::has_torso_det_train_dir() const {
  return _has_bit(33);
}
inline void ExpParam::clear_torso_det_train_dir() {
  if (torso_det_train_dir_ != &_default_torso_det_train_dir_) {
    torso_det_train_dir_->clear();
  }
  _clear_bit(33);
}
inline const ::std::string& ExpParam::torso_det_train_dir() const {
  return *torso_det_train_dir_;
}
inline void ExpParam::set_torso_det_train_dir(const ::std::string& value) {
  _set_bit(33);
  if (torso_det_train_dir_ == &_default_torso_det_train_dir_) {
    torso_det_train_dir_ = new ::std::string;
  }
  torso_det_train_dir_->assign(value);
}
inline void ExpParam::set_torso_det_train_dir(const char* value) {
  _set_bit(33);
  if (torso_det_train_dir_ == &_default_torso_det_train_dir_) {
    torso_det_train_dir_ = new ::std::string;
  }
  torso_det_train_dir_->assign(value);
}
inline void ExpParam::set_torso_det_train_dir(const char* value, size_t size) {
  _set_bit(33);
  if (torso_det_train_dir_ == &_default_torso_det_train_dir_) {
    torso_det_train_dir_ = new ::std::string;
  }
  torso_det_train_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_torso_det_train_dir() {
  _set_bit(33);
  if (torso_det_train_dir_ == &_default_torso_det_train_dir_) {
    torso_det_train_dir_ = new ::std::string;
  }
  return torso_det_train_dir_;
}

// optional uint32 poselet_rot_strip = 109;
inline bool ExpParam::has_poselet_rot_strip() const {
  return _has_bit(34);
}
inline void ExpParam::clear_poselet_rot_strip() {
  poselet_rot_strip_ = 0u;
  _clear_bit(34);
}
inline ::google::protobuf::uint32 ExpParam::poselet_rot_strip() const {
  return poselet_rot_strip_;
}
inline void ExpParam::set_poselet_rot_strip(::google::protobuf::uint32 value) {
  _set_bit(34);
  poselet_rot_strip_ = value;
}

// optional uint32 rootidx_det = 110 [default = 1000];
inline bool ExpParam::has_rootidx_det() const {
  return _has_bit(35);
}
inline void ExpParam::clear_rootidx_det() {
  rootidx_det_ = 1000u;
  _clear_bit(35);
}
inline ::google::protobuf::uint32 ExpParam::rootidx_det() const {
  return rootidx_det_;
}
inline void ExpParam::set_rootidx_det(::google::protobuf::uint32 value) {
  _set_bit(35);
  rootidx_det_ = value;
}

// optional bool use_gt_torso = 111 [default = false];
inline bool ExpParam::has_use_gt_torso() const {
  return _has_bit(36);
}
inline void ExpParam::clear_use_gt_torso() {
  use_gt_torso_ = false;
  _clear_bit(36);
}
inline bool ExpParam::use_gt_torso() const {
  return use_gt_torso_;
}
inline void ExpParam::set_use_gt_torso(bool value) {
  _set_bit(36);
  use_gt_torso_ = value;
}

// optional bool use_dpm_torso = 112 [default = false];
inline bool ExpParam::has_use_dpm_torso() const {
  return _has_bit(37);
}
inline void ExpParam::clear_use_dpm_torso() {
  use_dpm_torso_ = false;
  _clear_bit(37);
}
inline bool ExpParam::use_dpm_torso() const {
  return use_dpm_torso_;
}
inline void ExpParam::set_use_dpm_torso(bool value) {
  _set_bit(37);
  use_dpm_torso_ = value;
}

// optional bool pred_unary_pos = 114 [default = false];
inline bool ExpParam::has_pred_unary_pos() const {
  return _has_bit(38);
}
inline void ExpParam::clear_pred_unary_pos() {
  pred_unary_pos_ = false;
  _clear_bit(38);
}
inline bool ExpParam::pred_unary_pos() const {
  return pred_unary_pos_;
}
inline void ExpParam::set_pred_unary_pos(bool value) {
  _set_bit(38);
  pred_unary_pos_ = value;
}

// optional bool use_torso_pos_prior = 120 [default = false];
inline bool ExpParam::has_use_torso_pos_prior() const {
  return _has_bit(39);
}
inline void ExpParam::clear_use_torso_pos_prior() {
  use_torso_pos_prior_ = false;
  _clear_bit(39);
}
inline bool ExpParam::use_torso_pos_prior() const {
  return use_torso_pos_prior_;
}
inline void ExpParam::set_use_torso_pos_prior(bool value) {
  _set_bit(39);
  use_torso_pos_prior_ = value;
}

// optional bool use_dpm_head = 122 [default = false];
inline bool ExpParam::has_use_dpm_head() const {
  return _has_bit(40);
}
inline void ExpParam::clear_use_dpm_head() {
  use_dpm_head_ = false;
  _clear_bit(40);
}
inline bool ExpParam::use_dpm_head() const {
  return use_dpm_head_;
}
inline void ExpParam::set_use_dpm_head(bool value) {
  _set_bit(40);
  use_dpm_head_ = value;
}

// optional float dpm_head_weight = 125 [default = 1];
inline bool ExpParam::has_dpm_head_weight() const {
  return _has_bit(41);
}
inline void ExpParam::clear_dpm_head_weight() {
  dpm_head_weight_ = 1;
  _clear_bit(41);
}
inline float ExpParam::dpm_head_weight() const {
  return dpm_head_weight_;
}
inline void ExpParam::set_dpm_head_weight(float value) {
  _set_bit(41);
  dpm_head_weight_ = value;
}

// optional string test_dpm_unary_dir = 126;
inline bool ExpParam::has_test_dpm_unary_dir() const {
  return _has_bit(42);
}
inline void ExpParam::clear_test_dpm_unary_dir() {
  if (test_dpm_unary_dir_ != &_default_test_dpm_unary_dir_) {
    test_dpm_unary_dir_->clear();
  }
  _clear_bit(42);
}
inline const ::std::string& ExpParam::test_dpm_unary_dir() const {
  return *test_dpm_unary_dir_;
}
inline void ExpParam::set_test_dpm_unary_dir(const ::std::string& value) {
  _set_bit(42);
  if (test_dpm_unary_dir_ == &_default_test_dpm_unary_dir_) {
    test_dpm_unary_dir_ = new ::std::string;
  }
  test_dpm_unary_dir_->assign(value);
}
inline void ExpParam::set_test_dpm_unary_dir(const char* value) {
  _set_bit(42);
  if (test_dpm_unary_dir_ == &_default_test_dpm_unary_dir_) {
    test_dpm_unary_dir_ = new ::std::string;
  }
  test_dpm_unary_dir_->assign(value);
}
inline void ExpParam::set_test_dpm_unary_dir(const char* value, size_t size) {
  _set_bit(42);
  if (test_dpm_unary_dir_ == &_default_test_dpm_unary_dir_) {
    test_dpm_unary_dir_ = new ::std::string;
  }
  test_dpm_unary_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_test_dpm_unary_dir() {
  _set_bit(42);
  if (test_dpm_unary_dir_ == &_default_test_dpm_unary_dir_) {
    test_dpm_unary_dir_ = new ::std::string;
  }
  return test_dpm_unary_dir_;
}

// optional float dpm_unary_weight = 127 [default = 1];
inline bool ExpParam::has_dpm_unary_weight() const {
  return _has_bit(43);
}
inline void ExpParam::clear_dpm_unary_weight() {
  dpm_unary_weight_ = 1;
  _clear_bit(43);
}
inline float ExpParam::dpm_unary_weight() const {
  return dpm_unary_weight_;
}
inline void ExpParam::set_dpm_unary_weight(float value) {
  _set_bit(43);
  dpm_unary_weight_ = value;
}

// optional bool use_dpm_unary = 128 [default = false];
inline bool ExpParam::has_use_dpm_unary() const {
  return _has_bit(44);
}
inline void ExpParam::clear_use_dpm_unary() {
  use_dpm_unary_ = false;
  _clear_bit(44);
}
inline bool ExpParam::use_dpm_unary() const {
  return use_dpm_unary_;
}
inline void ExpParam::set_use_dpm_unary(bool value) {
  _set_bit(44);
  use_dpm_unary_ = value;
}

// optional bool do_dpm_rot = 131 [default = false];
inline bool ExpParam::has_do_dpm_rot() const {
  return _has_bit(45);
}
inline void ExpParam::clear_do_dpm_rot() {
  do_dpm_rot_ = false;
  _clear_bit(45);
}
inline bool ExpParam::do_dpm_rot() const {
  return do_dpm_rot_;
}
inline void ExpParam::set_do_dpm_rot(bool value) {
  _set_bit(45);
  do_dpm_rot_ = value;
}

// optional bool use_pairwise = 132 [default = true];
inline bool ExpParam::has_use_pairwise() const {
  return _has_bit(46);
}
inline void ExpParam::clear_use_pairwise() {
  use_pairwise_ = true;
  _clear_bit(46);
}
inline bool ExpParam::use_pairwise() const {
  return use_pairwise_;
}
inline void ExpParam::set_use_pairwise(bool value) {
  _set_bit(46);
  use_pairwise_ = value;
}

// optional bool save_part_marginals = 133 [default = false];
inline bool ExpParam::has_save_part_marginals() const {
  return _has_bit(47);
}
inline void ExpParam::clear_save_part_marginals() {
  save_part_marginals_ = false;
  _clear_bit(47);
}
inline bool ExpParam::save_part_marginals() const {
  return save_part_marginals_;
}
inline void ExpParam::set_save_part_marginals(bool value) {
  _set_bit(47);
  save_part_marginals_ = value;
}

// optional string dpm_model_dir = 134;
inline bool ExpParam::has_dpm_model_dir() const {
  return _has_bit(48);
}
inline void ExpParam::clear_dpm_model_dir() {
  if (dpm_model_dir_ != &_default_dpm_model_dir_) {
    dpm_model_dir_->clear();
  }
  _clear_bit(48);
}
inline const ::std::string& ExpParam::dpm_model_dir() const {
  return *dpm_model_dir_;
}
inline void ExpParam::set_dpm_model_dir(const ::std::string& value) {
  _set_bit(48);
  if (dpm_model_dir_ == &_default_dpm_model_dir_) {
    dpm_model_dir_ = new ::std::string;
  }
  dpm_model_dir_->assign(value);
}
inline void ExpParam::set_dpm_model_dir(const char* value) {
  _set_bit(48);
  if (dpm_model_dir_ == &_default_dpm_model_dir_) {
    dpm_model_dir_ = new ::std::string;
  }
  dpm_model_dir_->assign(value);
}
inline void ExpParam::set_dpm_model_dir(const char* value, size_t size) {
  _set_bit(48);
  if (dpm_model_dir_ == &_default_dpm_model_dir_) {
    dpm_model_dir_ = new ::std::string;
  }
  dpm_model_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_dpm_model_dir() {
  _set_bit(48);
  if (dpm_model_dir_ == &_default_dpm_model_dir_) {
    dpm_model_dir_ = new ::std::string;
  }
  return dpm_model_dir_;
}

// optional float unary_weight = 56 [default = 1];
inline bool ExpParam::has_unary_weight() const {
  return _has_bit(49);
}
inline void ExpParam::clear_unary_weight() {
  unary_weight_ = 1;
  _clear_bit(49);
}
inline float ExpParam::unary_weight() const {
  return unary_weight_;
}
inline void ExpParam::set_unary_weight(float value) {
  _set_bit(49);
  unary_weight_ = value;
}

// optional bool interpolate = 77 [default = false];
inline bool ExpParam::has_interpolate() const {
  return _has_bit(50);
}
inline void ExpParam::clear_interpolate() {
  interpolate_ = false;
  _clear_bit(50);
}
inline bool ExpParam::interpolate() const {
  return interpolate_;
}
inline void ExpParam::set_interpolate(bool value) {
  _set_bit(50);
  interpolate_ = value;
}

// optional string pos_dpm_torso_dir = 69;
inline bool ExpParam::has_pos_dpm_torso_dir() const {
  return _has_bit(51);
}
inline void ExpParam::clear_pos_dpm_torso_dir() {
  if (pos_dpm_torso_dir_ != &_default_pos_dpm_torso_dir_) {
    pos_dpm_torso_dir_->clear();
  }
  _clear_bit(51);
}
inline const ::std::string& ExpParam::pos_dpm_torso_dir() const {
  return *pos_dpm_torso_dir_;
}
inline void ExpParam::set_pos_dpm_torso_dir(const ::std::string& value) {
  _set_bit(51);
  if (pos_dpm_torso_dir_ == &_default_pos_dpm_torso_dir_) {
    pos_dpm_torso_dir_ = new ::std::string;
  }
  pos_dpm_torso_dir_->assign(value);
}
inline void ExpParam::set_pos_dpm_torso_dir(const char* value) {
  _set_bit(51);
  if (pos_dpm_torso_dir_ == &_default_pos_dpm_torso_dir_) {
    pos_dpm_torso_dir_ = new ::std::string;
  }
  pos_dpm_torso_dir_->assign(value);
}
inline void ExpParam::set_pos_dpm_torso_dir(const char* value, size_t size) {
  _set_bit(51);
  if (pos_dpm_torso_dir_ == &_default_pos_dpm_torso_dir_) {
    pos_dpm_torso_dir_ = new ::std::string;
  }
  pos_dpm_torso_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_pos_dpm_torso_dir() {
  _set_bit(51);
  if (pos_dpm_torso_dir_ == &_default_pos_dpm_torso_dir_) {
    pos_dpm_torso_dir_ = new ::std::string;
  }
  return pos_dpm_torso_dir_;
}

// optional string test_dpm_torso_dir = 71;
inline bool ExpParam::has_test_dpm_torso_dir() const {
  return _has_bit(52);
}
inline void ExpParam::clear_test_dpm_torso_dir() {
  if (test_dpm_torso_dir_ != &_default_test_dpm_torso_dir_) {
    test_dpm_torso_dir_->clear();
  }
  _clear_bit(52);
}
inline const ::std::string& ExpParam::test_dpm_torso_dir() const {
  return *test_dpm_torso_dir_;
}
inline void ExpParam::set_test_dpm_torso_dir(const ::std::string& value) {
  _set_bit(52);
  if (test_dpm_torso_dir_ == &_default_test_dpm_torso_dir_) {
    test_dpm_torso_dir_ = new ::std::string;
  }
  test_dpm_torso_dir_->assign(value);
}
inline void ExpParam::set_test_dpm_torso_dir(const char* value) {
  _set_bit(52);
  if (test_dpm_torso_dir_ == &_default_test_dpm_torso_dir_) {
    test_dpm_torso_dir_ = new ::std::string;
  }
  test_dpm_torso_dir_->assign(value);
}
inline void ExpParam::set_test_dpm_torso_dir(const char* value, size_t size) {
  _set_bit(52);
  if (test_dpm_torso_dir_ == &_default_test_dpm_torso_dir_) {
    test_dpm_torso_dir_ = new ::std::string;
  }
  test_dpm_torso_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_test_dpm_torso_dir() {
  _set_bit(52);
  if (test_dpm_torso_dir_ == &_default_test_dpm_torso_dir_) {
    test_dpm_torso_dir_ = new ::std::string;
  }
  return test_dpm_torso_dir_;
}

// optional uint32 torso_hyp_idx = 72;
inline bool ExpParam::has_torso_hyp_idx() const {
  return _has_bit(53);
}
inline void ExpParam::clear_torso_hyp_idx() {
  torso_hyp_idx_ = 0u;
  _clear_bit(53);
}
inline ::google::protobuf::uint32 ExpParam::torso_hyp_idx() const {
  return torso_hyp_idx_;
}
inline void ExpParam::set_torso_hyp_idx(::google::protobuf::uint32 value) {
  _set_bit(53);
  torso_hyp_idx_ = value;
}

// optional string part_marginals_dir = 73;
inline bool ExpParam::has_part_marginals_dir() const {
  return _has_bit(54);
}
inline void ExpParam::clear_part_marginals_dir() {
  if (part_marginals_dir_ != &_default_part_marginals_dir_) {
    part_marginals_dir_->clear();
  }
  _clear_bit(54);
}
inline const ::std::string& ExpParam::part_marginals_dir() const {
  return *part_marginals_dir_;
}
inline void ExpParam::set_part_marginals_dir(const ::std::string& value) {
  _set_bit(54);
  if (part_marginals_dir_ == &_default_part_marginals_dir_) {
    part_marginals_dir_ = new ::std::string;
  }
  part_marginals_dir_->assign(value);
}
inline void ExpParam::set_part_marginals_dir(const char* value) {
  _set_bit(54);
  if (part_marginals_dir_ == &_default_part_marginals_dir_) {
    part_marginals_dir_ = new ::std::string;
  }
  part_marginals_dir_->assign(value);
}
inline void ExpParam::set_part_marginals_dir(const char* value, size_t size) {
  _set_bit(54);
  if (part_marginals_dir_ == &_default_part_marginals_dir_) {
    part_marginals_dir_ = new ::std::string;
  }
  part_marginals_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_part_marginals_dir() {
  _set_bit(54);
  if (part_marginals_dir_ == &_default_part_marginals_dir_) {
    part_marginals_dir_ = new ::std::string;
  }
  return part_marginals_dir_;
}

// optional string part_conf = 5;
inline bool ExpParam::has_part_conf() const {
  return _has_bit(55);
}
inline void ExpParam::clear_part_conf() {
  if (part_conf_ != &_default_part_conf_) {
    part_conf_->clear();
  }
  _clear_bit(55);
}
inline const ::std::string& ExpParam::part_conf() const {
  return *part_conf_;
}
inline void ExpParam::set_part_conf(const ::std::string& value) {
  _set_bit(55);
  if (part_conf_ == &_default_part_conf_) {
    part_conf_ = new ::std::string;
  }
  part_conf_->assign(value);
}
inline void ExpParam::set_part_conf(const char* value) {
  _set_bit(55);
  if (part_conf_ == &_default_part_conf_) {
    part_conf_ = new ::std::string;
  }
  part_conf_->assign(value);
}
inline void ExpParam::set_part_conf(const char* value, size_t size) {
  _set_bit(55);
  if (part_conf_ == &_default_part_conf_) {
    part_conf_ = new ::std::string;
  }
  part_conf_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_part_conf() {
  _set_bit(55);
  if (part_conf_ == &_default_part_conf_) {
    part_conf_ = new ::std::string;
  }
  return part_conf_;
}

// optional string part_conf_eval = 32;
inline bool ExpParam::has_part_conf_eval() const {
  return _has_bit(56);
}
inline void ExpParam::clear_part_conf_eval() {
  if (part_conf_eval_ != &_default_part_conf_eval_) {
    part_conf_eval_->clear();
  }
  _clear_bit(56);
}
inline const ::std::string& ExpParam::part_conf_eval() const {
  return *part_conf_eval_;
}
inline void ExpParam::set_part_conf_eval(const ::std::string& value) {
  _set_bit(56);
  if (part_conf_eval_ == &_default_part_conf_eval_) {
    part_conf_eval_ = new ::std::string;
  }
  part_conf_eval_->assign(value);
}
inline void ExpParam::set_part_conf_eval(const char* value) {
  _set_bit(56);
  if (part_conf_eval_ == &_default_part_conf_eval_) {
    part_conf_eval_ = new ::std::string;
  }
  part_conf_eval_->assign(value);
}
inline void ExpParam::set_part_conf_eval(const char* value, size_t size) {
  _set_bit(56);
  if (part_conf_eval_ == &_default_part_conf_eval_) {
    part_conf_eval_ = new ::std::string;
  }
  part_conf_eval_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_part_conf_eval() {
  _set_bit(56);
  if (part_conf_eval_ == &_default_part_conf_eval_) {
    part_conf_eval_ = new ::std::string;
  }
  return part_conf_eval_;
}

// optional string part_conf_type = 33 [default = "human_full"];
inline bool ExpParam::has_part_conf_type() const {
  return _has_bit(57);
}
inline void ExpParam::clear_part_conf_type() {
  if (part_conf_type_ != &_default_part_conf_type_) {
    part_conf_type_->assign(_default_part_conf_type_);
  }
  _clear_bit(57);
}
inline const ::std::string& ExpParam::part_conf_type() const {
  return *part_conf_type_;
}
inline void ExpParam::set_part_conf_type(const ::std::string& value) {
  _set_bit(57);
  if (part_conf_type_ == &_default_part_conf_type_) {
    part_conf_type_ = new ::std::string;
  }
  part_conf_type_->assign(value);
}
inline void ExpParam::set_part_conf_type(const char* value) {
  _set_bit(57);
  if (part_conf_type_ == &_default_part_conf_type_) {
    part_conf_type_ = new ::std::string;
  }
  part_conf_type_->assign(value);
}
inline void ExpParam::set_part_conf_type(const char* value, size_t size) {
  _set_bit(57);
  if (part_conf_type_ == &_default_part_conf_type_) {
    part_conf_type_ = new ::std::string;
  }
  part_conf_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_part_conf_type() {
  _set_bit(57);
  if (part_conf_type_ == &_default_part_conf_type_) {
    part_conf_type_ = new ::std::string(_default_part_conf_type_);
  }
  return part_conf_type_;
}

// optional string abc_param = 6;
inline bool ExpParam::has_abc_param() const {
  return _has_bit(58);
}
inline void ExpParam::clear_abc_param() {
  if (abc_param_ != &_default_abc_param_) {
    abc_param_->clear();
  }
  _clear_bit(58);
}
inline const ::std::string& ExpParam::abc_param() const {
  return *abc_param_;
}
inline void ExpParam::set_abc_param(const ::std::string& value) {
  _set_bit(58);
  if (abc_param_ == &_default_abc_param_) {
    abc_param_ = new ::std::string;
  }
  abc_param_->assign(value);
}
inline void ExpParam::set_abc_param(const char* value) {
  _set_bit(58);
  if (abc_param_ == &_default_abc_param_) {
    abc_param_ = new ::std::string;
  }
  abc_param_->assign(value);
}
inline void ExpParam::set_abc_param(const char* value, size_t size) {
  _set_bit(58);
  if (abc_param_ == &_default_abc_param_) {
    abc_param_ = new ::std::string;
  }
  abc_param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_abc_param() {
  _set_bit(58);
  if (abc_param_ == &_default_abc_param_) {
    abc_param_ = new ::std::string;
  }
  return abc_param_;
}

// optional float min_object_scale = 9 [default = 1];
inline bool ExpParam::has_min_object_scale() const {
  return _has_bit(59);
}
inline void ExpParam::clear_min_object_scale() {
  min_object_scale_ = 1;
  _clear_bit(59);
}
inline float ExpParam::min_object_scale() const {
  return min_object_scale_;
}
inline void ExpParam::set_min_object_scale(float value) {
  _set_bit(59);
  min_object_scale_ = value;
}

// optional float max_object_scale = 10 [default = 1];
inline bool ExpParam::has_max_object_scale() const {
  return _has_bit(60);
}
inline void ExpParam::clear_max_object_scale() {
  max_object_scale_ = 1;
  _clear_bit(60);
}
inline float ExpParam::max_object_scale() const {
  return max_object_scale_;
}
inline void ExpParam::set_max_object_scale(float value) {
  _set_bit(60);
  max_object_scale_ = value;
}

// optional uint32 num_scale_steps = 11 [default = 1];
inline bool ExpParam::has_num_scale_steps() const {
  return _has_bit(61);
}
inline void ExpParam::clear_num_scale_steps() {
  num_scale_steps_ = 1u;
  _clear_bit(61);
}
inline ::google::protobuf::uint32 ExpParam::num_scale_steps() const {
  return num_scale_steps_;
}
inline void ExpParam::set_num_scale_steps(::google::protobuf::uint32 value) {
  _set_bit(61);
  num_scale_steps_ = value;
}

// optional float min_part_rotation = 12 [default = -180];
inline bool ExpParam::has_min_part_rotation() const {
  return _has_bit(62);
}
inline void ExpParam::clear_min_part_rotation() {
  min_part_rotation_ = -180;
  _clear_bit(62);
}
inline float ExpParam::min_part_rotation() const {
  return min_part_rotation_;
}
inline void ExpParam::set_min_part_rotation(float value) {
  _set_bit(62);
  min_part_rotation_ = value;
}

// optional float max_part_rotation = 13 [default = 180];
inline bool ExpParam::has_max_part_rotation() const {
  return _has_bit(63);
}
inline void ExpParam::clear_max_part_rotation() {
  max_part_rotation_ = 180;
  _clear_bit(63);
}
inline float ExpParam::max_part_rotation() const {
  return max_part_rotation_;
}
inline void ExpParam::set_max_part_rotation(float value) {
  _set_bit(63);
  max_part_rotation_ = value;
}

// optional uint32 num_rotation_steps = 14 [default = 48];
inline bool ExpParam::has_num_rotation_steps() const {
  return _has_bit(64);
}
inline void ExpParam::clear_num_rotation_steps() {
  num_rotation_steps_ = 48u;
  _clear_bit(64);
}
inline ::google::protobuf::uint32 ExpParam::num_rotation_steps() const {
  return num_rotation_steps_;
}
inline void ExpParam::set_num_rotation_steps(::google::protobuf::uint32 value) {
  _set_bit(64);
  num_rotation_steps_ = value;
}

// optional bool flip_orientation = 15 [default = false];
inline bool ExpParam::has_flip_orientation() const {
  return _has_bit(65);
}
inline void ExpParam::clear_flip_orientation() {
  flip_orientation_ = false;
  _clear_bit(65);
}
inline bool ExpParam::flip_orientation() const {
  return flip_orientation_;
}
inline void ExpParam::set_flip_orientation(bool value) {
  _set_bit(65);
  flip_orientation_ = value;
}

// optional float object_height_width_ratio = 21 [default = 2.5];
inline bool ExpParam::has_object_height_width_ratio() const {
  return _has_bit(66);
}
inline void ExpParam::clear_object_height_width_ratio() {
  object_height_width_ratio_ = 2.5f;
  _clear_bit(66);
}
inline float ExpParam::object_height_width_ratio() const {
  return object_height_width_ratio_;
}
inline void ExpParam::set_object_height_width_ratio(float value) {
  _set_bit(66);
  object_height_width_ratio_ = value;
}

// optional bool compute_part_marginals = 22 [default = true];
inline bool ExpParam::has_compute_part_marginals() const {
  return _has_bit(67);
}
inline void ExpParam::clear_compute_part_marginals() {
  compute_part_marginals_ = true;
  _clear_bit(67);
}
inline bool ExpParam::compute_part_marginals() const {
  return compute_part_marginals_;
}
inline void ExpParam::set_compute_part_marginals(bool value) {
  _set_bit(67);
  compute_part_marginals_ = value;
}

// optional int32 num_pose_samples = 23 [default = 0];
inline bool ExpParam::has_num_pose_samples() const {
  return _has_bit(68);
}
inline void ExpParam::clear_num_pose_samples() {
  num_pose_samples_ = 0;
  _clear_bit(68);
}
inline ::google::protobuf::int32 ExpParam::num_pose_samples() const {
  return num_pose_samples_;
}
inline void ExpParam::set_num_pose_samples(::google::protobuf::int32 value) {
  _set_bit(68);
  num_pose_samples_ = value;
}

// optional bool is_multicomponent = 40 [default = false];
inline bool ExpParam::has_is_multicomponent() const {
  return _has_bit(69);
}
inline void ExpParam::clear_is_multicomponent() {
  is_multicomponent_ = false;
  _clear_bit(69);
}
inline bool ExpParam::is_multicomponent() const {
  return is_multicomponent_;
}
inline void ExpParam::set_is_multicomponent(bool value) {
  _set_bit(69);
  is_multicomponent_ = value;
}

// optional int32 num_components = 41 [default = 1];
inline bool ExpParam::has_num_components() const {
  return _has_bit(70);
}
inline void ExpParam::clear_num_components() {
  num_components_ = 1;
  _clear_bit(70);
}
inline ::google::protobuf::int32 ExpParam::num_components() const {
  return num_components_;
}
inline void ExpParam::set_num_components(::google::protobuf::int32 value) {
  _set_bit(70);
  num_components_ = value;
}

// optional string mix_dir = 45;
inline bool ExpParam::has_mix_dir() const {
  return _has_bit(71);
}
inline void ExpParam::clear_mix_dir() {
  if (mix_dir_ != &_default_mix_dir_) {
    mix_dir_->clear();
  }
  _clear_bit(71);
}
inline const ::std::string& ExpParam::mix_dir() const {
  return *mix_dir_;
}
inline void ExpParam::set_mix_dir(const ::std::string& value) {
  _set_bit(71);
  if (mix_dir_ == &_default_mix_dir_) {
    mix_dir_ = new ::std::string;
  }
  mix_dir_->assign(value);
}
inline void ExpParam::set_mix_dir(const char* value) {
  _set_bit(71);
  if (mix_dir_ == &_default_mix_dir_) {
    mix_dir_ = new ::std::string;
  }
  mix_dir_->assign(value);
}
inline void ExpParam::set_mix_dir(const char* value, size_t size) {
  _set_bit(71);
  if (mix_dir_ == &_default_mix_dir_) {
    mix_dir_ = new ::std::string;
  }
  mix_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_mix_dir() {
  _set_bit(71);
  if (mix_dir_ == &_default_mix_dir_) {
    mix_dir_ = new ::std::string;
  }
  return mix_dir_;
}

// optional float strip_border_detections = 24 [default = 0];
inline bool ExpParam::has_strip_border_detections() const {
  return _has_bit(72);
}
inline void ExpParam::clear_strip_border_detections() {
  strip_border_detections_ = 0;
  _clear_bit(72);
}
inline float ExpParam::strip_border_detections() const {
  return strip_border_detections_;
}
inline void ExpParam::set_strip_border_detections(float value) {
  _set_bit(72);
  strip_border_detections_ = value;
}

// optional bool save_image_scoregrid = 25 [default = false];
inline bool ExpParam::has_save_image_scoregrid() const {
  return _has_bit(73);
}
inline void ExpParam::clear_save_image_scoregrid() {
  save_image_scoregrid_ = false;
  _clear_bit(73);
}
inline bool ExpParam::save_image_scoregrid() const {
  return save_image_scoregrid_;
}
inline void ExpParam::set_save_image_scoregrid(bool value) {
  _set_bit(73);
  save_image_scoregrid_ = value;
}

// optional int32 dai_num_samples = 28 [default = 1000];
inline bool ExpParam::has_dai_num_samples() const {
  return _has_bit(74);
}
inline void ExpParam::clear_dai_num_samples() {
  dai_num_samples_ = 1000;
  _clear_bit(74);
}
inline ::google::protobuf::int32 ExpParam::dai_num_samples() const {
  return dai_num_samples_;
}
inline void ExpParam::set_dai_num_samples(::google::protobuf::int32 value) {
  _set_bit(74);
  dai_num_samples_ = value;
}

// optional string dai_factors = 29 [default = ""];
inline bool ExpParam::has_dai_factors() const {
  return _has_bit(75);
}
inline void ExpParam::clear_dai_factors() {
  if (dai_factors_ != &_default_dai_factors_) {
    dai_factors_->clear();
  }
  _clear_bit(75);
}
inline const ::std::string& ExpParam::dai_factors() const {
  return *dai_factors_;
}
inline void ExpParam::set_dai_factors(const ::std::string& value) {
  _set_bit(75);
  if (dai_factors_ == &_default_dai_factors_) {
    dai_factors_ = new ::std::string;
  }
  dai_factors_->assign(value);
}
inline void ExpParam::set_dai_factors(const char* value) {
  _set_bit(75);
  if (dai_factors_ == &_default_dai_factors_) {
    dai_factors_ = new ::std::string;
  }
  dai_factors_->assign(value);
}
inline void ExpParam::set_dai_factors(const char* value, size_t size) {
  _set_bit(75);
  if (dai_factors_ == &_default_dai_factors_) {
    dai_factors_ = new ::std::string;
  }
  dai_factors_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_dai_factors() {
  _set_bit(75);
  if (dai_factors_ == &_default_dai_factors_) {
    dai_factors_ = new ::std::string;
  }
  return dai_factors_;
}

// optional string dai_samples_dir = 30 [default = ""];
inline bool ExpParam::has_dai_samples_dir() const {
  return _has_bit(76);
}
inline void ExpParam::clear_dai_samples_dir() {
  if (dai_samples_dir_ != &_default_dai_samples_dir_) {
    dai_samples_dir_->clear();
  }
  _clear_bit(76);
}
inline const ::std::string& ExpParam::dai_samples_dir() const {
  return *dai_samples_dir_;
}
inline void ExpParam::set_dai_samples_dir(const ::std::string& value) {
  _set_bit(76);
  if (dai_samples_dir_ == &_default_dai_samples_dir_) {
    dai_samples_dir_ = new ::std::string;
  }
  dai_samples_dir_->assign(value);
}
inline void ExpParam::set_dai_samples_dir(const char* value) {
  _set_bit(76);
  if (dai_samples_dir_ == &_default_dai_samples_dir_) {
    dai_samples_dir_ = new ::std::string;
  }
  dai_samples_dir_->assign(value);
}
inline void ExpParam::set_dai_samples_dir(const char* value, size_t size) {
  _set_bit(76);
  if (dai_samples_dir_ == &_default_dai_samples_dir_) {
    dai_samples_dir_ = new ::std::string;
  }
  dai_samples_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_dai_samples_dir() {
  _set_bit(76);
  if (dai_samples_dir_ == &_default_dai_samples_dir_) {
    dai_samples_dir_ = new ::std::string;
  }
  return dai_samples_dir_;
}

// optional string dai_bp_type = 31 [default = "sumprod"];
inline bool ExpParam::has_dai_bp_type() const {
  return _has_bit(77);
}
inline void ExpParam::clear_dai_bp_type() {
  if (dai_bp_type_ != &_default_dai_bp_type_) {
    dai_bp_type_->assign(_default_dai_bp_type_);
  }
  _clear_bit(77);
}
inline const ::std::string& ExpParam::dai_bp_type() const {
  return *dai_bp_type_;
}
inline void ExpParam::set_dai_bp_type(const ::std::string& value) {
  _set_bit(77);
  if (dai_bp_type_ == &_default_dai_bp_type_) {
    dai_bp_type_ = new ::std::string;
  }
  dai_bp_type_->assign(value);
}
inline void ExpParam::set_dai_bp_type(const char* value) {
  _set_bit(77);
  if (dai_bp_type_ == &_default_dai_bp_type_) {
    dai_bp_type_ = new ::std::string;
  }
  dai_bp_type_->assign(value);
}
inline void ExpParam::set_dai_bp_type(const char* value, size_t size) {
  _set_bit(77);
  if (dai_bp_type_ == &_default_dai_bp_type_) {
    dai_bp_type_ = new ::std::string;
  }
  dai_bp_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_dai_bp_type() {
  _set_bit(77);
  if (dai_bp_type_ == &_default_dai_bp_type_) {
    dai_bp_type_ = new ::std::string(_default_dai_bp_type_);
  }
  return dai_bp_type_;
}

// optional string dai_samples_type = 34 [default = "part_post"];
inline bool ExpParam::has_dai_samples_type() const {
  return _has_bit(78);
}
inline void ExpParam::clear_dai_samples_type() {
  if (dai_samples_type_ != &_default_dai_samples_type_) {
    dai_samples_type_->assign(_default_dai_samples_type_);
  }
  _clear_bit(78);
}
inline const ::std::string& ExpParam::dai_samples_type() const {
  return *dai_samples_type_;
}
inline void ExpParam::set_dai_samples_type(const ::std::string& value) {
  _set_bit(78);
  if (dai_samples_type_ == &_default_dai_samples_type_) {
    dai_samples_type_ = new ::std::string;
  }
  dai_samples_type_->assign(value);
}
inline void ExpParam::set_dai_samples_type(const char* value) {
  _set_bit(78);
  if (dai_samples_type_ == &_default_dai_samples_type_) {
    dai_samples_type_ = new ::std::string;
  }
  dai_samples_type_->assign(value);
}
inline void ExpParam::set_dai_samples_type(const char* value, size_t size) {
  _set_bit(78);
  if (dai_samples_type_ == &_default_dai_samples_type_) {
    dai_samples_type_ = new ::std::string;
  }
  dai_samples_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_dai_samples_type() {
  _set_bit(78);
  if (dai_samples_type_ == &_default_dai_samples_type_) {
    dai_samples_type_ = new ::std::string(_default_dai_samples_type_);
  }
  return dai_samples_type_;
}

// optional bool dai_bbox_prior = 35 [default = false];
inline bool ExpParam::has_dai_bbox_prior() const {
  return _has_bit(79);
}
inline void ExpParam::clear_dai_bbox_prior() {
  dai_bbox_prior_ = false;
  _clear_bit(79);
}
inline bool ExpParam::dai_bbox_prior() const {
  return dai_bbox_prior_;
}
inline void ExpParam::set_dai_bbox_prior(bool value) {
  _set_bit(79);
  dai_bbox_prior_ = value;
}

// optional bool dai_bbox_prior_annopoints = 37 [default = false];
inline bool ExpParam::has_dai_bbox_prior_annopoints() const {
  return _has_bit(80);
}
inline void ExpParam::clear_dai_bbox_prior_annopoints() {
  dai_bbox_prior_annopoints_ = false;
  _clear_bit(80);
}
inline bool ExpParam::dai_bbox_prior_annopoints() const {
  return dai_bbox_prior_annopoints_;
}
inline void ExpParam::set_dai_bbox_prior_annopoints(bool value) {
  _set_bit(80);
  dai_bbox_prior_annopoints_ = value;
}

// optional bool dai_multiperson = 36 [default = false];
inline bool ExpParam::has_dai_multiperson() const {
  return _has_bit(81);
}
inline void ExpParam::clear_dai_multiperson() {
  dai_multiperson_ = false;
  _clear_bit(81);
}
inline bool ExpParam::dai_multiperson() const {
  return dai_multiperson_;
}
inline void ExpParam::set_dai_multiperson(bool value) {
  _set_bit(81);
  dai_multiperson_ = value;
}

// optional string detection_masks_dir = 38 [default = ""];
inline bool ExpParam::has_detection_masks_dir() const {
  return _has_bit(82);
}
inline void ExpParam::clear_detection_masks_dir() {
  if (detection_masks_dir_ != &_default_detection_masks_dir_) {
    detection_masks_dir_->clear();
  }
  _clear_bit(82);
}
inline const ::std::string& ExpParam::detection_masks_dir() const {
  return *detection_masks_dir_;
}
inline void ExpParam::set_detection_masks_dir(const ::std::string& value) {
  _set_bit(82);
  if (detection_masks_dir_ == &_default_detection_masks_dir_) {
    detection_masks_dir_ = new ::std::string;
  }
  detection_masks_dir_->assign(value);
}
inline void ExpParam::set_detection_masks_dir(const char* value) {
  _set_bit(82);
  if (detection_masks_dir_ == &_default_detection_masks_dir_) {
    detection_masks_dir_ = new ::std::string;
  }
  detection_masks_dir_->assign(value);
}
inline void ExpParam::set_detection_masks_dir(const char* value, size_t size) {
  _set_bit(82);
  if (detection_masks_dir_ == &_default_detection_masks_dir_) {
    detection_masks_dir_ = new ::std::string;
  }
  detection_masks_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_detection_masks_dir() {
  _set_bit(82);
  if (detection_masks_dir_ == &_default_detection_masks_dir_) {
    detection_masks_dir_ = new ::std::string;
  }
  return detection_masks_dir_;
}

// optional string roi_annolist = 42 [default = ""];
inline bool ExpParam::has_roi_annolist() const {
  return _has_bit(83);
}
inline void ExpParam::clear_roi_annolist() {
  if (roi_annolist_ != &_default_roi_annolist_) {
    roi_annolist_->clear();
  }
  _clear_bit(83);
}
inline const ::std::string& ExpParam::roi_annolist() const {
  return *roi_annolist_;
}
inline void ExpParam::set_roi_annolist(const ::std::string& value) {
  _set_bit(83);
  if (roi_annolist_ == &_default_roi_annolist_) {
    roi_annolist_ = new ::std::string;
  }
  roi_annolist_->assign(value);
}
inline void ExpParam::set_roi_annolist(const char* value) {
  _set_bit(83);
  if (roi_annolist_ == &_default_roi_annolist_) {
    roi_annolist_ = new ::std::string;
  }
  roi_annolist_->assign(value);
}
inline void ExpParam::set_roi_annolist(const char* value, size_t size) {
  _set_bit(83);
  if (roi_annolist_ == &_default_roi_annolist_) {
    roi_annolist_ = new ::std::string;
  }
  roi_annolist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpParam::mutable_roi_annolist() {
  _set_bit(83);
  if (roi_annolist_ == &_default_roi_annolist_) {
    roi_annolist_ = new ::std::string;
  }
  return roi_annolist_;
}

// optional int32 roi_extend_x = 46 [default = -1];
inline bool ExpParam::has_roi_extend_x() const {
  return _has_bit(84);
}
inline void ExpParam::clear_roi_extend_x() {
  roi_extend_x_ = -1;
  _clear_bit(84);
}
inline ::google::protobuf::int32 ExpParam::roi_extend_x() const {
  return roi_extend_x_;
}
inline void ExpParam::set_roi_extend_x(::google::protobuf::int32 value) {
  _set_bit(84);
  roi_extend_x_ = value;
}

// optional int32 roi_extend_y = 47 [default = -1];
inline bool ExpParam::has_roi_extend_y() const {
  return _has_bit(85);
}
inline void ExpParam::clear_roi_extend_y() {
  roi_extend_y_ = -1;
  _clear_bit(85);
}
inline ::google::protobuf::int32 ExpParam::roi_extend_y() const {
  return roi_extend_y_;
}
inline void ExpParam::set_roi_extend_y(::google::protobuf::int32 value) {
  _set_bit(85);
  roi_extend_y_ = value;
}

// optional float roi_save_num_samples = 48 [default = 1000];
inline bool ExpParam::has_roi_save_num_samples() const {
  return _has_bit(86);
}
inline void ExpParam::clear_roi_save_num_samples() {
  roi_save_num_samples_ = 1000;
  _clear_bit(86);
}
inline float ExpParam::roi_save_num_samples() const {
  return roi_save_num_samples_;
}
inline void ExpParam::set_roi_save_num_samples(float value) {
  _set_bit(86);
  roi_save_num_samples_ = value;
}

// optional bool compute_max = 43 [default = false];
inline bool ExpParam::has_compute_max() const {
  return _has_bit(87);
}
inline void ExpParam::clear_compute_max() {
  compute_max_ = false;
  _clear_bit(87);
}
inline bool ExpParam::compute_max() const {
  return compute_max_;
}
inline void ExpParam::set_compute_max(bool value) {
  _set_bit(87);
  compute_max_ = value;
}

// optional bool reweight_inference = 53 [default = false];
inline bool ExpParam::has_reweight_inference() const {
  return _has_bit(88);
}
inline void ExpParam::clear_reweight_inference() {
  reweight_inference_ = false;
  _clear_bit(88);
}
inline bool ExpParam::reweight_inference() const {
  return reweight_inference_;
}
inline void ExpParam::set_reweight_inference(bool value) {
  _set_bit(88);
  reweight_inference_ = value;
}

// optional bool save_root_marginal = 136 [default = false];
inline bool ExpParam::has_save_root_marginal() const {
  return _has_bit(89);
}
inline void ExpParam::clear_save_root_marginal() {
  save_root_marginal_ = false;
  _clear_bit(89);
}
inline bool ExpParam::save_root_marginal() const {
  return save_root_marginal_;
}
inline void ExpParam::set_save_root_marginal(bool value) {
  _set_bit(89);
  save_root_marginal_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ExpParam_2eproto__INCLUDED
